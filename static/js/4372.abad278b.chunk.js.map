{"version":3,"file":"static/js/4372.abad278b.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js","../node_modules/@adobecom/utils/decorate.js","../node_modules/@adobecom/blocks/section-metadata/section-metadata.js","../node_modules/@adobecom/blocks/section-metadata/sticky-section.js"],"sourcesContent":["function _taggedTemplateLiteral(e, t) {\n  return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {\n    raw: {\n      value: Object.freeze(t)\n    }\n  }));\n}\nexport { _taggedTemplateLiteral as default };","import {\n  createTag,\n  loadStyle,\n  getConfig,\n  createIntersectionObserver,\n  getFederatedContentRoot,\n  getFedsPlaceholderConfig,\n  shouldBlockFreeTrialLinks,\n} from './utils.js';\n\nconst { miloLibs, codeRoot } = getConfig();\nconst HIDE_CONTROLS = '_hide-controls';\nlet firstVideo = null;\nlet videoLabels = {\n  playMotion: 'Play',\n  pauseMotion: 'Pause',\n  pauseIcon: 'Pause icon',\n  playIcon: 'Play icon',\n  hasFetched: false,\n};\nconst isReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;\nlet videoCounter = 0;\n\nexport function decorateButtons(el, size) {\n  const buttons = el.querySelectorAll('em a, strong a, p > a strong');\n  if (buttons.length === 0) return;\n  const buttonTypeMap = { STRONG: 'blue', EM: 'outline', A: 'blue' };\n  const localePrefix = getConfig()?.locale?.prefix;\n\n  buttons.forEach((button) => {\n    const parent = button.parentElement;\n    if (shouldBlockFreeTrialLinks({ button, localePrefix, parent })) return;\n    let target = button;\n    const buttonType = buttonTypeMap[parent.nodeName] || 'outline';\n    if (button.nodeName === 'STRONG') {\n      target = parent;\n    } else {\n      parent.insertAdjacentElement('afterend', button);\n      parent.remove();\n    }\n    target.classList.add('con-button', buttonType);\n    if (size) target.classList.add(size); /* button-l, button-xl */\n    const customClasses = target.href && [...target.href.matchAll(/#_button-([a-zA-Z-]+)/g)];\n    if (customClasses) {\n      customClasses.forEach((match) => {\n        target.href = target.href.replace(match[0], '');\n        if (target.dataset.modalHash) {\n          target.setAttribute('data-modal-hash', target.dataset.modalHash.replace(match[0], ''));\n        }\n        target.classList.add(match[1]);\n      });\n    }\n    const actionArea = button.closest('p, div');\n    if (actionArea) {\n      actionArea.classList.add('action-area');\n      actionArea.nextElementSibling?.classList.add('supplemental-text', 'body-xl');\n    }\n  });\n}\n\nexport function decorateIconStack(el) {\n  const ulElems = el.querySelectorAll('ul');\n  if (!ulElems.length) return;\n  const stackEl = ulElems[ulElems.length - 1];\n  stackEl.classList.add('icon-stack-area', 'body-s');\n  el.classList.add('icon-stack');\n  const items = stackEl.querySelectorAll('li');\n  [...items].forEach((i) => {\n    const links = i.querySelectorAll('a');\n    if (links.length <= 1) return;\n    const picIndex = links[0].querySelector('a picture') ? 0 : 1;\n    const linkImg = links[picIndex];\n    const linkText = links[1 - picIndex];\n    const linkPic = linkImg.querySelector('picture');\n    if (linkPic) {\n      linkText.prepend(linkPic);\n      linkImg.remove();\n    }\n  });\n}\n\nexport function decorateIconArea(el) {\n  const icons = el.querySelectorAll('.icon');\n  icons.forEach((icon) => {\n    icon.parentElement.classList.add('icon-area');\n    if (icon.textContent.includes('persona')) icon.parentElement.classList.add('persona-area');\n  });\n}\n\nfunction elContainsText(el) {\n  return [...el.childNodes].some(({ nodeType, innerText, textContent }) => (\n    (nodeType === Node.ELEMENT_NODE && innerText.trim() !== '')\n    || (nodeType === Node.TEXT_NODE && textContent.trim() !== '')\n  ));\n}\n\nexport function decorateBlockText(el, config = ['m', 's', 'm'], type = null) {\n  if (!el.classList.contains('default')) {\n    let headings = el?.querySelectorAll('h1, h2, h3, h4, h5, h6');\n    if (headings) {\n      if (type === 'hasDetailHeading' && headings.length > 1) headings = [...headings].splice(1);\n      headings.forEach((h) => h.classList.add(`heading-${config[0]}`));\n      if (config[2]) {\n        const prevSib = headings[0]?.previousElementSibling;\n        prevSib?.classList.toggle(`detail-${config[2]}`, !prevSib.querySelector('picture'));\n        decorateIconArea(el);\n      }\n    }\n    const bodyStyle = `body-${config[1]}`;\n    const emptyEls = el?.querySelectorAll(':is(p, ul, ol, div):not([class])');\n    if (emptyEls.length) {\n      [...emptyEls].filter(elContainsText).forEach((e) => e.classList.add(bodyStyle));\n    } else if (!el.classList.length && elContainsText(el)) {\n      el.classList.add(bodyStyle);\n    }\n  }\n  const buttonSize = config.length > 3 ? `button-${config[3]}` : '';\n  decorateButtons(el, buttonSize);\n  if (type === 'merch') decorateIconStack(el);\n}\n\nexport function handleFocalpoint(pic, child, removeChild) {\n  const image = pic.querySelector('img');\n  if (!child || !image) return;\n  let text = '';\n  if (child.childElementCount === 2) {\n    const dataElement = child.querySelectorAll('p')[1];\n    text = dataElement?.textContent;\n    if (removeChild) dataElement?.remove();\n  } else if (child.textContent) {\n    text = child.textContent;\n    const childData = child.childNodes;\n    if (removeChild) childData.forEach((c) => c.nodeType === Node.TEXT_NODE && c.remove());\n  }\n  if (!text) return;\n  const directions = text.trim().toLowerCase().split(',');\n  const [x, y = ''] = directions;\n  image.style.objectPosition = `${x} ${y}`;\n}\n\nexport async function decorateBlockBg(block, node, { useHandleFocalpoint = false, className = 'background' } = {}) {\n  const childCount = node.childElementCount;\n  if (node.querySelector('img, video, a[href*=\".mp4\"]') || childCount > 1) {\n    node.classList.add(className);\n    const binaryVP = [['mobile-only'], ['tablet-only', 'desktop-only']];\n    const allVP = [['mobile-only'], ['tablet-only'], ['desktop-only']];\n    const viewports = childCount === 2 ? binaryVP : allVP;\n    [...node.children].forEach((child, i) => {\n      if (childCount > 1 && i < viewports.length) child.classList.add(...viewports[i]);\n      const pic = child.querySelector('picture');\n      if (useHandleFocalpoint && pic\n        && (child.childElementCount === 2 || child.textContent?.trim())) {\n        handleFocalpoint(pic, child, true);\n      }\n      if (!child.querySelector('img, video, a[href*=\".mp4\"]')) {\n        child.style.background = child.textContent;\n        child.classList.add('expand-background');\n        child.textContent = '';\n      }\n    });\n  } else {\n    block.style.background = node.textContent;\n    node.remove();\n  }\n}\n\nexport function getBlockSize(el, defaultSize = 1) {\n  const sizes = ['small', 'medium', 'large', 'xlarge', 'medium-compact'];\n  if (defaultSize < 0 || defaultSize > sizes.length - 1) return null;\n  return sizes.find((size) => el.classList.contains(size)) || sizes[defaultSize];\n}\n\nexport const decorateBlockHrs = (el) => {\n  const pTags = el.querySelectorAll('p');\n  let hasHr = false;\n  const decorateHr = ((tag) => {\n    const hrTag = tag.textContent.trim().startsWith('---');\n    if (!hrTag) return;\n    hasHr = true;\n    const bgStyle = tag.textContent.substring(3).trim();\n    const hrElem = createTag('hr', { style: `background: ${bgStyle};` });\n    tag.textContent = '';\n    tag.appendChild(hrElem);\n  });\n  [...pTags].forEach((p) => {\n    decorateHr(p);\n  });\n  const singleElementInRow = el.children[0].childElementCount === 0;\n  if (singleElementInRow) {\n    decorateHr(el.children[0]);\n  }\n  if (hasHr) el.classList.add('has-divider');\n};\n\nfunction applyTextOverrides(el, override, targetEl) {\n  const parts = override.split('-');\n  const type = parts[1];\n  const scopeEl = (targetEl !== false) ? targetEl : el;\n  const els = scopeEl.querySelectorAll(`[class^=\"${type}\"]`);\n  if (!els.length) return;\n  els.forEach((elem) => {\n    const replace = [...elem.classList].find((i) => i.startsWith(type));\n    elem.classList.replace(replace, `${parts[1]}-${parts[0]}`);\n  });\n}\n\nexport function decorateTextOverrides(el, options = ['-heading', '-body', '-detail'], target = false) {\n  const overrides = [...el.classList]\n    .filter((elClass) => options.findIndex((ovClass) => elClass.endsWith(ovClass)) >= 0);\n  if (!overrides.length) return;\n  overrides.forEach((override) => {\n    applyTextOverrides(el, override, target);\n    el.classList.remove(override);\n  });\n}\n\nfunction defineDeviceByScreenSize() {\n  const screenWidth = window.innerWidth;\n  if (screenWidth <= 600) {\n    return 'mobile';\n  }\n  return 'desktop';\n}\n\nexport function getImgSrc(pic) {\n  let source = '';\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(pic, 'text/html');\n  if (defineDeviceByScreenSize() === 'mobile') source = doc.querySelector('source[type=\"image/webp\"]:not([media])');\n  else source = doc.querySelector('source[type=\"image/webp\"][media]');\n  return source?.srcset ? `poster='${source.srcset}'` : '';\n}\n\nexport function getVideoAttrs(hash, dataset) {\n  const isAutoplay = hash?.includes('autoplay');\n  const isAutoplayOnce = hash?.includes('autoplay1');\n  const playOnHover = hash?.includes('hoverplay');\n  const playInViewport = hash?.includes('viewportplay');\n  const poster = getImgSrc(dataset.videoPoster);\n  const globalAttrs = `playsinline ${poster}`;\n  const autoPlayAttrs = 'autoplay muted';\n  const playInViewportAttrs = playInViewport ? 'data-play-viewport' : '';\n\n  if (isAutoplay && !isAutoplayOnce) {\n    return `${globalAttrs} ${autoPlayAttrs} loop ${playInViewportAttrs}`;\n  }\n  if (playOnHover && isAutoplayOnce) {\n    return `${globalAttrs} ${autoPlayAttrs} data-hoverplay`;\n  }\n  if (playOnHover) {\n    return `${globalAttrs} muted data-hoverplay`;\n  }\n  if (isAutoplayOnce) {\n    return `${globalAttrs} ${autoPlayAttrs} ${playInViewportAttrs}`;\n  }\n  return `${globalAttrs} controls`;\n}\n\nexport function syncPausePlayIcon(video, event) {\n  if (!video.getAttributeNames().includes('data-hoverplay')) {\n    const offsetFiller = video.closest('.video-holder').querySelector('.offset-filler');\n    if (event?.type === 'playing' && offsetFiller?.classList.contains('is-playing')) return;\n    const anchorTag = video.closest('.video-holder').querySelector('a');\n    offsetFiller?.classList.toggle('is-playing');\n    const isPlaying = offsetFiller?.classList.contains('is-playing');\n    const indexOfVideo = (anchorTag.getAttribute('video-index') === '1' && videoCounter === 1) ? '' : anchorTag.getAttribute('video-index');\n    const changedLabel = `${isPlaying ? videoLabels?.pauseMotion : videoLabels?.playMotion}`;\n    const oldLabel = `${!isPlaying ? videoLabels?.pauseMotion : videoLabels?.playMotion}`;\n    const ariaLabel = `${changedLabel} ${indexOfVideo}`.trim();\n    anchorTag?.setAttribute('title', `${ariaLabel}`);\n    anchorTag?.setAttribute('aria-label', `${ariaLabel} `);\n    anchorTag?.setAttribute('aria-pressed', isPlaying ? 'true' : 'false');\n    const daaLL = anchorTag.getAttribute('daa-ll');\n    if (daaLL) anchorTag.setAttribute('daa-ll', daaLL.replace(oldLabel, changedLabel));\n  }\n}\n\nexport function addAccessibilityControl(videoString, videoAttrs, indexOfVideo, tabIndex = 0) {\n  if (videoAttrs.includes('controls')) return videoString;\n  const fedRoot = getFederatedContentRoot();\n  if (videoAttrs.includes('hoverplay')) {\n    return `<a class='pause-play-wrapper video-holder' tabindex=${tabIndex}>${videoString}</a>`;\n  }\n  return `\n    <div class='video-container video-holder'>${videoString}\n      <a class='pause-play-wrapper' title='${videoLabels.pauseMotion}' aria-label='${videoLabels.pauseMotion}' role='button' tabindex=${tabIndex} aria-pressed=true video-index=${indexOfVideo}>\n        <div class='offset-filler'>\n          <img class='accessibility-control pause-icon' alt='${videoLabels.pauseIcon}' src='${fedRoot}/federal/assets/svgs/accessibility-pause.svg'/>\n          <img class='accessibility-control play-icon' alt='${videoLabels.playIcon}' src='${fedRoot}/federal/assets/svgs/accessibility-play.svg'/>\n        </div>\n      </a>\n    </div>\n  `;\n}\n\nfunction isVideoReady(video) {\n  return video.readyState > 1 && document.visibilityState === 'visible';\n}\n\nexport function handlePause(event) {\n  if (event.code !== 'Enter' && event.code !== 'Space' && !['focus', 'click', 'blur'].includes(event.type)) {\n    return;\n  }\n  event.preventDefault();\n  event.stopPropagation();\n  const video = event.target.closest('.video-holder').parentElement.querySelector('video');\n  if (event.type === 'blur') {\n    video.pause();\n  } else if (video.paused || video.ended || event.type === 'focus') {\n    if (isVideoReady(video)) { video.play(); }\n  } else {\n    video.pause();\n  }\n  syncPausePlayIcon(video);\n}\n\nexport function applyHoverPlay(video) {\n  if (!video) return;\n  if (video.hasAttribute('data-hoverplay')) {\n    video.parentElement.addEventListener('focus', handlePause);\n    video.parentElement.addEventListener('blur', handlePause);\n    if (!video.hasAttribute('data-mouseevent')) {\n      video.addEventListener('mouseenter', () => { if (isVideoReady(video)) { video.play(); } });\n      video.addEventListener('mouseleave', () => { if (isVideoReady(video)) { video.pause(); } });\n      video.addEventListener('ended', () => { syncPausePlayIcon(video); });\n      video.setAttribute('data-mouseevent', true);\n    }\n  }\n}\n\nexport function applyAccessibilityEvents(videoEl) {\n  const pausePlayWrapper = videoEl.parentElement.querySelector('.pause-play-wrapper') || videoEl.closest('.pause-play-wrapper');\n  if (pausePlayWrapper?.querySelector('.accessibility-control')) {\n    pausePlayWrapper.addEventListener('click', handlePause);\n    pausePlayWrapper.addEventListener('keydown', handlePause);\n  }\n  if (videoEl.hasAttribute('autoplay')) {\n    videoEl.addEventListener('playing', (event) => syncPausePlayIcon(videoEl, event));\n    videoEl.addEventListener('ended', () => syncPausePlayIcon(videoEl));\n    if (isReducedMotion) {\n      videoEl.pause();\n      return;\n    }\n    videoEl.addEventListener('canplay', () => isVideoReady(videoEl) && videoEl.play());\n  }\n}\n\nfunction setObjectFitAndPos(text, pic, bgEl, objFitOptions) {\n  const backgroundConfig = text.split(',').map((c) => c.toLowerCase().trim());\n  const fitOption = objFitOptions.filter((c) => backgroundConfig.includes(c));\n  const focusOption = backgroundConfig.filter((c) => !fitOption.includes(c));\n  if (fitOption) [pic.querySelector('img').style.objectFit] = fitOption;\n  bgEl.innerHTML = '';\n  bgEl.append(pic);\n  bgEl.append(document.createTextNode(focusOption.join(',')));\n}\n\nexport function handleObjectFit(bgRow) {\n  const bgConfig = bgRow.querySelectorAll('div');\n  [...bgConfig].forEach((r) => {\n    const pic = r.querySelector('picture');\n    if (!pic) return;\n    let text = '';\n    const pchild = [...r.querySelectorAll('p:not(:empty)')].filter((p) => p.innerHTML.trim() !== '');\n    if (pchild.length > 2) text = pchild[1]?.textContent.trim();\n    if (!text && r.textContent) text = r.textContent;\n    if (!text) return;\n    setObjectFitAndPos(text, pic, r, ['fill', 'contain', 'cover', 'none', 'scale-down']);\n  });\n}\n\nfunction getVideoIntersectionObserver() {\n  if (!window?.videoIntersectionObs) {\n    window.videoIntersectionObs = new window.IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        const { intersectionRatio, target: video } = entry;\n        const isHaveLoopAttr = video.getAttributeNames().includes('loop');\n        const { playedOnce = false } = video.dataset;\n        const isPlaying = video.currentTime > 0 && !video.paused && !video.ended\n          && video.readyState > video.HAVE_CURRENT_DATA;\n\n        if (intersectionRatio <= 0.8) {\n          video.pause();\n        } else if ((isHaveLoopAttr || !playedOnce) && !isPlaying) {\n          video.play();\n        }\n      });\n    }, { threshold: [0.8] });\n  }\n  return window.videoIntersectionObs;\n}\n\nfunction applyInViewPortPlay(video) {\n  if (!video) return;\n  if (video.hasAttribute('data-play-viewport')) {\n    const observer = getVideoIntersectionObserver();\n    video.addEventListener('ended', () => {\n      video.dataset.playedOnce = true;\n    });\n    observer.observe(video);\n  }\n}\n\nexport function decorateMultiViewport(el) {\n  const foreground = el.querySelector('.foreground');\n  const cols = foreground.childElementCount;\n  if (cols === 2 || cols === 3) {\n    const viewports = [\n      '(max-width: 599px)',\n      '(min-width: 600px) and (max-width: 1199px)',\n      '(min-width: 1200px)',\n      '(min-width: 600px)',\n    ].filter((v, i) => (cols === 2 ? [0, 3].includes(i) : i !== 3));\n    [...foreground.children].forEach((child, index) => {\n      const mq = window.matchMedia(viewports[index]);\n      const setContent = () => mq.matches && foreground.replaceChildren(child);\n      setContent();\n      mq.addEventListener('change', setContent);\n    });\n  }\n  return foreground;\n}\n\nexport async function loadCDT(el, classList) {\n  try {\n    await Promise.all([\n      loadStyle(`${miloLibs || codeRoot}/features/cdt/cdt.css`),\n      import('../features/cdt/cdt.js')\n        .then(({ default: initCDT }) => initCDT(el, classList)),\n    ]);\n  } catch (error) {\n    window.lana?.log(`WARN: Failed to load countdown timer: ${error}`, { tags: 'errorType=warn,module=countdown-timer' });\n  }\n}\n\nexport function isVideoAccessible(anchorTag) {\n  return !anchorTag?.hash.includes(HIDE_CONTROLS);\n}\n\nfunction updateFirstVideo() {\n  if (firstVideo != null && firstVideo?.controls === false && videoCounter > 1) {\n    let videoHolder = document.querySelector('[video-index=\"1\"]') || firstVideo.closest('.video-holder');\n    if (videoHolder.nodeName !== 'A') videoHolder = videoHolder.querySelector('a.pause-play-wrapper');\n    const firstVideoLabel = videoHolder.getAttribute('aria-label');\n    videoHolder.setAttribute('aria-label', `${firstVideoLabel} 1`);\n    firstVideo = null;\n  }\n}\n\nfunction updateAriaLabel(videoEl, videoAttrs) {\n  if (!videoEl.getAttributeNames().includes('data-hoverplay')) {\n    const pausePlayWrapper = videoEl.parentElement.querySelector('.pause-play-wrapper') || videoEl.closest('.pause-play-wrapper');\n    const pauseIcon = pausePlayWrapper.querySelector('.pause-icon');\n    const playIcon = pausePlayWrapper.querySelector('.play-icon');\n    const indexOfVideo = pausePlayWrapper.getAttribute('video-index');\n    let ariaLabel = `${videoAttrs.includes('autoplay') ? videoLabels.pauseMotion : videoLabels.playMotion}`;\n    ariaLabel = ariaLabel.concat(` ${indexOfVideo === '1' && videoCounter === 1 ? '' : indexOfVideo}`);\n    pausePlayWrapper.setAttribute('aria-label', ariaLabel);\n    pauseIcon.setAttribute('alt', videoLabels.pauseMotion);\n    playIcon.setAttribute('alt', videoLabels.playMotion);\n    updateFirstVideo();\n  }\n}\n\nexport function decoratePausePlayWrapper(videoEl, videoAttrs) {\n  if (!videoLabels.hasFetched) {\n    import('../features/placeholders.js').then(({ replaceKeyArray }) => {\n      replaceKeyArray(['pause-motion', 'play-motion', 'pause-icon', 'play-icon'], getFedsPlaceholderConfig())\n        .then(([pauseMotion, playMotion, pauseIcon, playIcon]) => {\n          videoLabels = { playMotion, pauseMotion, pauseIcon, playIcon };\n          videoLabels.hasFetched = true;\n          updateAriaLabel(videoEl, videoAttrs);\n        });\n    });\n  } else {\n    updateAriaLabel(videoEl, videoAttrs);\n  }\n}\n\nexport function decorateAnchorVideo({ src = '', anchorTag }) {\n  if (!src.length || !(anchorTag instanceof HTMLElement)) return;\n  const accessibilityEnabled = isVideoAccessible(anchorTag);\n  anchorTag.hash = anchorTag.hash.replace(`#${HIDE_CONTROLS}`, '');\n  if (anchorTag.closest('.marquee, .aside, .hero-marquee, .quiz-marquee') && !anchorTag.hash) anchorTag.hash = '#autoplay';\n  const { dataset, parentElement } = anchorTag;\n  const attrs = getVideoAttrs(anchorTag.hash, dataset);\n  const tabIndex = anchorTag.tabIndex || 0;\n  const videoIndex = (tabIndex === -1) ? 'tabindex=-1' : '';\n  let video = `<video ${attrs} data-video-source=${src} ${videoIndex}></video>`;\n  if (!attrs.includes('controls') && !attrs.includes('hoverplay') && accessibilityEnabled) {\n    videoCounter += 1;\n  }\n  const indexOfVideo = videoCounter;\n  if (accessibilityEnabled) {\n    video = addAccessibilityControl(video, attrs, indexOfVideo, tabIndex);\n  }\n  anchorTag.insertAdjacentHTML('afterend', video);\n  const videoEl = parentElement.querySelector('video');\n  if (indexOfVideo === 1) {\n    firstVideo = videoEl;\n  }\n\n  createIntersectionObserver({\n    el: videoEl,\n    options: { rootMargin: '1000px' },\n    callback: () => {\n      if (videoEl.querySelector('source')) return;\n      videoEl.appendChild(createTag('source', { src, type: 'video/mp4' }));\n    },\n  });\n\n  if (videoEl.controls) {\n    const io = new IntersectionObserver((entries) => {\n      entries.forEach(({ isIntersecting, target }) => {\n        if (!isIntersecting && !target.paused) target.pause();\n      });\n    }, { rootMargin: '0px' });\n    io.observe(videoEl);\n  }\n\n  if (accessibilityEnabled) {\n    applyAccessibilityEvents(videoEl);\n    if (!videoEl.controls) {\n      decoratePausePlayWrapper(videoEl, attrs);\n    }\n  }\n  applyHoverPlay(videoEl);\n  applyInViewPortPlay(videoEl);\n  anchorTag.remove();\n}\n","import { handleFocalpoint } from '../../utils/decorate.js';\nimport { createTag, getFedsPlaceholderConfig } from '../../utils/utils.js';\n\nconst replacePlaceholder = async (key) => {\n  const { replaceKey } = await import('../../features/placeholders.js');\n  return replaceKey(key, getFedsPlaceholderConfig());\n};\nconst ADD_MORE_ICON = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"25\" fill=\"none\"><path fill=\"#292929\" d=\"M12 24.24c-6.617 0-12-5.383-12-12s5.383-12 12-12 12 5.383 12 12-5.383 12-12 12Zm0-21.943c-5.483 0-9.943 4.46-9.943 9.943s4.46 9.943 9.943 9.943 9.943-4.46 9.943-9.943S17.483 2.297 12 2.297Z\"/><path fill=\"#292929\" d=\"M16.55 11.188h-3.5v-3.5a1.05 1.05 0 0 0-2.1 0v3.5h-3.5a1.05 1.05 0 0 0 0 2.1h3.5v3.5a1.05 1.05 0 0 0 2.1 0v-3.5h3.5a1.05 1.05 0 0 0 0-2.1Z\"/></svg>';\n\nconst mediaQueries = {\n  mobile: window.matchMedia('(max-width: 599px)'),\n  tablet: window.matchMedia('(min-width: 600px) and (max-width: 1199px)'),\n};\n\nconst applyBackground = (colors, section) => {\n  if (colors.length === 1) {\n    const [color] = colors;\n    section.style.background = color;\n    return;\n  }\n  if (colors.length === 2) {\n    const [mobileColor, tabletDesktopColor] = colors;\n    section.style.background = mediaQueries.mobile.matches ? mobileColor : tabletDesktopColor;\n    return;\n  }\n  if (colors.length >= 3) {\n    const [mobileColor, tabletColor, desktopColor] = colors;\n    if (mediaQueries.mobile.matches) {\n      section.style.background = mobileColor;\n    } else if (mediaQueries.tablet.matches) {\n      section.style.background = tabletColor;\n    } else {\n      section.style.background = desktopColor;\n    }\n  }\n};\n\nexport function handleBackground(div, section) {\n  const pic = div.background.content?.querySelector('picture');\n  if (pic) {\n    section.classList.add('has-background');\n    pic.classList.add('section-background');\n    handleFocalpoint(pic, div.background.content);\n    section.insertAdjacentElement('afterbegin', pic);\n  } else {\n    const color = div.background.content?.textContent?.trim();\n    if (color) {\n      const colors = color.split('|').map((c) => c.trim());\n      applyBackground(colors, section);\n      Object.keys(mediaQueries).forEach((key) => {\n        mediaQueries[key].addEventListener('change', () => applyBackground(colors, section), 100);\n      });\n    }\n  }\n}\n\nexport async function handleStyle(text, section) {\n  if (!text || !section) return;\n  const styles = text.split(', ').map((style) => style.replaceAll(' ', '-'));\n  const sticky = styles.find((style) => style === 'sticky-top' || style === 'sticky-bottom');\n  if (sticky) {\n    const { default: handleStickySection } = await import('./sticky-section.js');\n    await handleStickySection(sticky, section);\n  }\n  if (styles.includes('masonry')) styles.push('masonry-up');\n  section.classList.add(...styles);\n}\n\nfunction handleMasonry(text, section) {\n  section.classList.add(...['masonry-layout', 'masonry-up']);\n  const divs = section.querySelectorAll(\":scope > div:not([class*='metadata'])\");\n  const spans = [];\n  text.split('\\n').forEach((line) => spans.push(...line.trim().split(',')));\n  [...divs].forEach((div, i) => {\n    const spanWidth = spans[i] ? spans[i] : 'span 4';\n    div.classList.add(`grid-${spanWidth.trim().replace(' ', '-')}`);\n  });\n}\n\nfunction handleLayout(text, section) {\n  if (!(text || section)) return;\n  const layoutClass = `grid-template-columns-${text.replaceAll(' | ', '-')}`;\n  section.classList.add(layoutClass);\n}\n\nexport function getDelayTime(time) {\n  if (time > 99) return time;\n  return (time * 1000);\n}\n\nfunction handleDelay(time, section) {\n  if (!(time || section)) return;\n  section.classList.add('hide-sticky-section');\n  setTimeout(() => { section.classList.remove('hide-sticky-section'); }, getDelayTime(time));\n}\n\nfunction handleAnchor(anchor, section) {\n  if (!anchor || !section) return;\n  section.id = anchor.toLowerCase().trim().replaceAll(/\\s+/g, '-');\n  section.classList.add('section-anchor');\n}\n\nexport const getMetadata = (el) => [...el.childNodes].reduce((rdx, row) => {\n  if (row.children) {\n    const key = row.children[0].textContent.trim().toLowerCase();\n    const content = row.children[1];\n    const text = content?.textContent.trim().toLowerCase();\n    if (key && content) rdx[key] = { content, text };\n  }\n  return rdx;\n}, {});\n\nasync function createAndConfigureShowMoreButton(section, cardsCount) {\n  const seeMoreText = await replacePlaceholder('see-more-features');\n  const showMoreButton = createTag(\n    'div',\n    { class: `show-more-button${cardsCount <= 3 ? ' hidden' : ''}` },\n  );\n  const button = createTag('button', {}, seeMoreText);\n\n  const iconSpan = createTag('span', {\n    class: 'show-more-icon',\n    'aria-hidden': 'true',\n  }, `${ADD_MORE_ICON}`);\n  button.appendChild(iconSpan);\n\n  button.addEventListener('click', () => {\n    section.classList.add('show-all');\n    section.querySelector('.show-more-button').remove();\n  });\n\n  showMoreButton.append(button);\n  return showMoreButton;\n}\n\nasync function handleCollapseSection(section) {\n  if (!section) return;\n  const blocks = section.querySelectorAll(':scope > div:not(:last-child)');\n  const showMoreButton = await createAndConfigureShowMoreButton(section, blocks.length);\n  section.append(showMoreButton);\n  const { decorateDefaultLinkAnalytics } = await import('../../martech/attributes.js');\n  decorateDefaultLinkAnalytics(showMoreButton);\n}\n\nfunction addListAttrToSection(section) {\n  if (!section) return;\n  const isSectionUp = [...section.classList].some((c) => c.endsWith('-up'));\n  const hasHeader = section.querySelector('h1, h2, h3, h4, h5, h6');\n  const allowedBlocks = ['icon-block', 'action-item', 'section-metadata'];\n  const hasAllowedChildren = [...section.children]\n    .every((child) => allowedBlocks.some((block) => child.classList.contains(block)));\n  if (!isSectionUp || hasHeader || !hasAllowedChildren) return;\n  section.setAttribute('role', 'list');\n  [...section.children].forEach((child) => {\n    if (child.classList.contains('section-metadata')) return;\n    child.setAttribute('role', 'listitem');\n  });\n}\n\nexport default async function init(el) {\n  const section = el.closest('.section');\n  const metadata = getMetadata(el);\n  if (metadata.style) await handleStyle(metadata.style.text, section);\n  if (metadata.background) handleBackground(metadata, section);\n  if (metadata.layout) handleLayout(metadata.layout.text, section);\n  if (metadata.masonry) handleMasonry(metadata.masonry.text, section);\n  if (metadata.delay) handleDelay(metadata.delay.text, section);\n  if (metadata.anchor) handleAnchor(metadata.anchor.text, section);\n  if (metadata['collapse-ups-mobile']?.text === 'on') await handleCollapseSection(section);\n  addListAttrToSection(section);\n}\n","import { createTag } from '../../utils/utils.js';\nimport { getMetadata, getDelayTime } from './section-metadata.js';\nimport { getGnavHeight } from '../global-navigation/utilities/utilities.js';\n\nfunction handleTopHeight(section) {\n  const topHeight = getGnavHeight();\n  section.style.top = `${topHeight}px`;\n}\n\nfunction promoIntersectObserve(el, stickySectionEl, options = {}) {\n  return new IntersectionObserver((entries, observer) => {\n    entries.forEach((entry) => {\n      if (el.classList.contains('close-sticky-section')) {\n        window.removeEventListener('resize', handleTopHeight);\n        observer.unobserve(entry.target);\n        return;\n      }\n\n      const { target, isIntersecting } = entry;\n\n      const abovePromoStart = (target === stickySectionEl && isIntersecting)\n        || stickySectionEl?.getBoundingClientRect().y > 0;\n\n      if (target === document.querySelector('footer')) {\n        el.classList.toggle('fill-sticky-section', isIntersecting);\n      } else if (target === document.querySelector('.hide-at-intersection')) {\n        const shouldHideSticky = isIntersecting\n        || entry.boundingClientRect.top < 0\n        || stickySectionEl?.getBoundingClientRect().y > 0;\n        el.classList.toggle('hide-sticky-section', shouldHideSticky);\n      } else el.classList.toggle('hide-sticky-section', abovePromoStart);\n    });\n  }, options);\n}\n\nfunction handleStickyPromobar(section, delay) {\n  const main = document.querySelector('main');\n  section.classList.add('promo-sticky-section', 'hide-sticky-section');\n  if (section.querySelector('.popup:is(.promobar)')) section.classList.add('popup');\n  let stickySectionEl = null;\n  let hasScrollControl;\n  if ((section.querySelector(':is(.promobar, .notification)').classList.contains('no-delay'))\n    || (delay && section.classList.contains('popup'))) {\n    hasScrollControl = true;\n    section.classList.remove('hide-sticky-section');\n  }\n  const metadata = getMetadata(section.querySelector('.section-metadata'));\n\n  if (!hasScrollControl && main.children[0] !== section) {\n    const isStickyAfterCTA = metadata?.style?.text.includes('sticky-after-cta');\n\n    if (isStickyAfterCTA) {\n      stickySectionEl = main.children[0].querySelector('.action-area');\n      stickySectionEl?.classList.add('show-sticky-section');\n    } else {\n      stickySectionEl = createTag('div', { class: 'section show-sticky-section' });\n      section.parentElement.insertBefore(stickySectionEl, section);\n    }\n  }\n  const io = promoIntersectObserve(section, stickySectionEl);\n  if (stickySectionEl) io.observe(stickySectionEl);\n  if (section.querySelector(':is(.promobar, .notification)')) {\n    io.observe(document.querySelector('footer'));\n  }\n\n  const selector = metadata?.['custom-hide']?.text?.trim();\n  const targetElement = selector ? document.querySelector(selector) : null;\n  if (targetElement) {\n    stickySectionEl = createTag('div', { class: 'hide-at-intersection' });\n    targetElement.parentElement.insertBefore(stickySectionEl, targetElement);\n    io.observe(stickySectionEl);\n  }\n}\n\nexport default async function handleStickySection(sticky, section) {\n  const main = document.querySelector('main');\n  switch (sticky) {\n    case 'sticky-top': {\n      const { debounce } = await import('../../utils/action.js');\n      window.addEventListener('resize', debounce(() => handleTopHeight(section)));\n      handleTopHeight(section);\n      main.prepend(section);\n      break;\n    }\n    case 'sticky-bottom': {\n      if (section.querySelector(':is(.promobar, .notification)')) {\n        const metadata = getMetadata(section.querySelector('.section-metadata'));\n        const delay = getDelayTime(metadata.delay?.text);\n        if (delay) setTimeout(() => { handleStickyPromobar(section, delay); }, delay);\n        else handleStickyPromobar(section, delay);\n      }\n      main.append(section);\n      break;\n    }\n    default:\n      break;\n  }\n}\n"],"names":["_taggedTemplateLiteral","e","t","slice","Object","freeze","defineProperties","raw","value","miloLibs","codeRoot","getConfig","window","matchMedia","matches","replacePlaceholder","async","replaceKey","key","getFedsPlaceholderConfig","ADD_MORE_ICON","mediaQueries","mobile","tablet","applyBackground","colors","section","length","mobileColor","tabletColor","desktopColor","style","background","tabletDesktopColor","color","handleBackground","div","_div$background$conte","pic","content","querySelector","classList","add","child","removeChild","image","text","childElementCount","dataElement","querySelectorAll","textContent","remove","childData","childNodes","forEach","c","nodeType","Node","TEXT_NODE","directions","trim","toLowerCase","split","x","y","objectPosition","concat","handleFocalpoint","insertAdjacentElement","_div$background$conte2","map","keys","addEventListener","handleStyle","styles","replaceAll","sticky","find","default","handleStickySection","includes","push","getDelayTime","time","getMetadata","el","reduce","rdx","row","children","handleCollapseSection","blocks","showMoreButton","cardsCount","seeMoreText","createTag","class","button","iconSpan","appendChild","append","createAndConfigureShowMoreButton","decorateDefaultLinkAnalytics","init","_metadata$collapseUp","closest","metadata","layout","layoutClass","handleLayout","masonry","divs","spans","line","i","spanWidth","replace","handleMasonry","delay","setTimeout","handleDelay","anchor","id","handleAnchor","isSectionUp","some","endsWith","hasHeader","allowedBlocks","hasAllowedChildren","every","block","contains","setAttribute","addListAttrToSection","handleTopHeight","topHeight","getGnavHeight","top","handleStickyPromobar","_metadata$customHide","main","document","hasScrollControl","stickySectionEl","_metadata$style","_stickySectionEl","parentElement","insertBefore","io","IntersectionObserver","entries","observer","entry","removeEventListener","unobserve","target","isIntersecting","abovePromoStart","getBoundingClientRect","toggle","shouldHideSticky","boundingClientRect","arguments","undefined","promoIntersectObserve","observe","selector","targetElement","debounce","prepend","_metadata$delay"],"sourceRoot":""}