{"version":3,"file":"static/js/3459.019efcec.chunk.js","mappings":"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","sources":["../node_modules/@adobecom/utils/automated-aria.js"],"sourcesContent":["import { getConfig, getFederatedContentRoot } from './utils.js';\n\nconst h1h2Regex = /^h[1-2]$/i;\nconst traverseForTextBeforeHeader = (node, regex) => {\n  if (regex.test(node.tagName)) return { text: '', foundHeader: true };\n  if (node.nodeType === Node.TEXT_NODE) return { text: node.nodeValue, foundHeader: false };\n  let text = '';\n  let foundHeader = false;\n  for (const child of node.childNodes) {\n    const result = traverseForTextBeforeHeader(child, regex);\n    text += result.text;\n    if (result.foundHeader) {\n      foundHeader = true;\n      break;\n    }\n  }\n  return { text, foundHeader };\n};\n\nexport const getTextBeforeHeader = (block) => {\n  if (!block) return '';\n  const { text, foundHeader } = traverseForTextBeforeHeader(block, h1h2Regex);\n  return foundHeader ? text.trim() : '';\n};\n\nexport const getProduct = (text, productNames) => {\n  if (!text) return '';\n  return productNames.find(({ us }) => text.toLowerCase().includes(us.toLowerCase()))?.us || '';\n};\n\nfunction addClassPartToSet(className, parts, extractPrefix) {\n  const segments = className.split('-');\n  if (segments.length > 1) {\n    const partIndex = extractPrefix ? 0 : segments.length - 1;\n    parts.add(segments[partIndex]);\n  }\n}\n\n// Extracts either prefixes or suffixes from a div's class names into a Set\nconst extractClassParts = (div, extractPrefix) => {\n  const classNames = Array.from(div.classList);\n  const parts = new Set();\n  for (const className of classNames) {\n    addClassPartToSet(className, parts, extractPrefix);\n  }\n  return parts;\n};\n\nfunction mapPartToIndices(parts, partToDivIndices, index) {\n  parts.forEach((part) => {\n    if (!partToDivIndices.has(part)) {\n      partToDivIndices.set(part, new Set());\n    }\n    partToDivIndices.get(part).add(index);\n  });\n}\n\n// Helper function to map class parts to the divs that have them\nconst mapPartsToDivIndices = (divs, extractPrefix) => {\n  const partToDivIndices = new Map();\n  divs.forEach((div, index) => {\n    const parts = extractClassParts(div, extractPrefix);\n    mapPartToIndices(parts, partToDivIndices, index);\n  });\n  return partToDivIndices;\n};\n\n// Main function to check for shared class patterns\nconst hasSharedClassPattern = (divs, { extractPrefix = false } = {}) => {\n  if (divs.length < 2) return false; // Need at least 2 divs to share anything\n  const partToDivIndices = mapPartsToDivIndices(divs, extractPrefix);\n  return Array.from(partToDivIndices.values()).some((divIndices) => divIndices.size > 1);\n};\n\nfunction addDeepestContainers(div, findRepeatingContainers, deepestContainers) {\n  const nestedContainers = findRepeatingContainers(div);\n  if (!nestedContainers.length) return;\n\n  let toPush = [];\n  if (nestedContainers.length > 1) {\n    toPush = [...nestedContainers, div];\n  } else if (nestedContainers.length === 1 && nestedContainers[0] === div) {\n    toPush = [div];\n  }\n  deepestContainers.push(...toPush);\n}\n\n// Processes nested divs to find the deepest repeating containers\nconst findDeepestRepeatingContainers = (repeatingDivs, findRepeatingContainers) => {\n  const deepestContainers = [];\n  for (const div of repeatingDivs) {\n    addDeepestContainers(div, findRepeatingContainers, deepestContainers);\n  }\n  return deepestContainers;\n};\n\nconst findRepeatingSiblings = (divs) => divs.filter(\n  (div) => divs.some((otherDiv) => div !== otherDiv && (\n    hasSharedClassPattern([div, otherDiv], { extractPrefix: true })\n      || hasSharedClassPattern([div, otherDiv], { extractPrefix: false })\n  )),\n);\n\n// Finds divs that repeat with a shared class pattern at the same DOM level\n// Containers must be siblings with a shared prefix (e.g., 'card-')\n// or suffix (e.g., '-item') and occur more than once.\nexport const findBlockContainers = (parentContainer) => {\n  const childDivs = Array.from(parentContainer.children).filter((element) => element.tagName === 'DIV');\n  if (!childDivs.length) return [parentContainer];\n\n  const repeatingSiblingDivs = findRepeatingSiblings(childDivs);\n\n  if (repeatingSiblingDivs.length > 1) {\n    const deepestContainers = findDeepestRepeatingContainers(\n      repeatingSiblingDivs,\n      findBlockContainers,\n    );\n    return deepestContainers.length > 1 ? deepestContainers : [parentContainer];\n  }\n\n  const nestedRepeatingContainers = childDivs\n    .map((div) => findBlockContainers(div))\n    .filter((containers) => containers.length > 1);\n\n  return nestedRepeatingContainers.length === 1 && nestedRepeatingContainers[0].length > 1\n    ? nestedRepeatingContainers[0]\n    : [parentContainer];\n};\n\n// Retrieves all h1-h6 headers within container.\nexport const getHeaders = (container) => Array.from(container.querySelectorAll('h1, h2, h3, h4, h5, h6'));\n\n// Helper to get headers outside containers\nconst getHeadersOutsideContainers = (block, containers) => {\n  const allHeaders = getHeaders(block);\n  const containedHeaders = containers.flatMap((c) => getHeaders(c));\n  return allHeaders.filter((h) => !containedHeaders.includes(h));\n};\n\n// Helper to assign ARIA label based on product or header\nconst tryAssignAriaLabel = (\n  cta,\n  headers,\n  productNames,\n  textsToAddProductNames,\n  textsToAddHeaders,\n  textBeforeHeader,\n) => {\n  // Filter out all headers of a level if there are multiple of that level\n  const singleOccurrenceHeaders = headers.filter((header) => {\n    const level = header.tagName.toLowerCase();\n    return headers.filter((h) => h.tagName.toLowerCase() === level).length === 1;\n  });\n\n  const buttonText = cta.textContent.trim().toLowerCase();\n  const productInCTA = (!cta.classList.contains('modal') && getProduct(cta.href?.replace('-', ' '), productNames)) || '';\n  const allContent = [...singleOccurrenceHeaders, textBeforeHeader].filter(Boolean);\n\n  if (textsToAddProductNames.includes(buttonText)) {\n    const productHeader = allContent.find((header) => {\n      const text = typeof header === 'string' ? header : header.textContent.trim();\n      const product = getProduct(text, productNames);\n      return product && (product.includes(productInCTA)\n        || productInCTA.includes(product) || !productInCTA);\n    });\n    if (productHeader) {\n      const productName = getProduct(productHeader.textContent?.trim()\n        || productHeader, productNames);\n      cta.setAttribute('aria-label', `${cta.textContent} ${productName}`);\n      return true;\n    }\n  }\n\n  if (textsToAddHeaders.includes(buttonText) && allContent.length) {\n    const headerText = allContent[0].textContent?.trim() || allContent[0];\n    cta.setAttribute('aria-label', `${cta.textContent} - ${headerText}`);\n    return true;\n  }\n\n  return false;\n};\n\n// Adds an ARIA label to a CTA element based on context (product names or headers).\nexport const addAriaLabelToCTA = (cta, productNames, textsToAddProductNames, textsToAddHeaders) => {\n  const block = cta.closest('.section > div');\n  if (!block) return;\n\n  const containers = findBlockContainers(block);\n  const ctaContainers = containers.filter((container) => container.contains(cta)) || [block];\n  const isInContainer = ctaContainers[0] !== block;\n\n  // Try to assign label from containers first\n  for (const container of ctaContainers) {\n    if (isInContainer && tryAssignAriaLabel(\n      cta,\n      getHeaders(container),\n      productNames,\n      textsToAddProductNames,\n      textsToAddHeaders,\n      getTextBeforeHeader(container),\n    )) return;\n  }\n\n  const uncontainedHeaders = getHeadersOutsideContainers(block, containers);\n  if (uncontainedHeaders.length && tryAssignAriaLabel(\n    cta,\n    uncontainedHeaders,\n    productNames,\n    textsToAddProductNames,\n    textsToAddHeaders,\n  )) {\n    return;\n  }\n  const textBeforeHeader = getTextBeforeHeader(block);\n  tryAssignAriaLabel(\n    cta,\n    getHeaders(block),\n    productNames,\n    textsToAddProductNames,\n    textsToAddHeaders,\n    textBeforeHeader,\n  );\n};\n\n/**\n * Asynchronously adds ARIA labels to all eligible CTAs on the page.\n * Fetches configuration and product names, then applies labels based on locale.\n */\nexport default async function addAriaLabels() {\n  const selector = getConfig().ariaLabelCTASelector || '.con-button:not([aria-label])';\n  const ctas = [...document.body.querySelectorAll(selector)].filter((button) => {\n    const ariaLabel = button.getAttribute('aria-label');\n    return ariaLabel !== '';\n  });\n  if (!ctas.length) return;\n\n  const logError = (msg, error) => window.lana.log(`${msg}: ${error}`, { tags: 'aria' });\n\n  const [configResponse, namesResponse] = await Promise.all([\n    fetch(`${getFederatedContentRoot()}/federal/assets/data/cta-aria-label-config.json`)\n      .catch((e) => logError('Could not fetch cta-aria-label-config.json', e)),\n    fetch(`${getFederatedContentRoot()}/federal/assets/data/product-names.json`)\n      .catch((e) => logError('Could not fetch product-names.json', e)),\n  ]);\n\n  if (!configResponse || !namesResponse) return;\n\n  const ctaAriaLabelConfig = await configResponse.json()\n    .catch((e) => logError('Could not parse cta-aria-label-config.json', e));\n  const productNames = await namesResponse.json()\n    .catch((e) => logError('Could not parse product-names.json', e));\n\n  if (!ctaAriaLabelConfig || !productNames) return;\n\n  const { prefix } = getConfig().locale;\n  const localePrefix = prefix?.replace('/', '') || 'us';\n\n  if (!ctaAriaLabelConfig.data?.length || !productNames.data?.length) {\n    window.lana.log(\n      `No cta aria label config or product names found for locale ${localePrefix}`,\n      { tags: 'aria' },\n    );\n    return;\n  }\n\n  const configForLocale = ctaAriaLabelConfig.data.find((item) => item.prefixes.split(',')\n    .map((p) => p.trim())\n    .includes(localePrefix));\n  if (!configForLocale) return;\n\n  const textsToAddProductNames = configForLocale.addProductName\n    .split(/[\\n,]+/)\n    .map((t) => t.trim().toLowerCase())\n    .filter(Boolean);\n  const textsToAddHeaders = configForLocale.addHeader\n    .split(/[\\n,]+/)\n    .map((t) => t.trim().toLowerCase())\n    .filter(Boolean);\n\n  const modifiedCTAs = [];\n  ctas.forEach((cta) => {\n    addAriaLabelToCTA(cta, productNames.data, textsToAddProductNames, textsToAddHeaders);\n    if (cta.hasAttribute('aria-label')) modifiedCTAs.push(cta);\n  });\n}\n"],"names":["T","H","traverseForTextBeforeHeader","t","n","test","tagName","text","foundHeader","nodeType","Node","TEXT_NODE","nodeValue","e","r","o","childNodes","i","A","trim","x","getProduct","_n$find","find","_ref","us","toLowerCase","includes","y","split","length","add","S","mapPartsToDivIndices","Map","forEach","extractClassParts","Array","from","classList","Set","P","has","set","get","$","L","extractPrefix","arguments","undefined","values","some","size","j","push","w","children","filter","B","findDeepestRepeatingContainers","N","map","p","querySelectorAll","b","tryAssignAriaLabel","_t$href","u","s","f","g","d","textContent","c","contains","href","replace","l","Boolean","a","_s$textContent","setAttribute","concat","_l$0$textContent","E","addAriaLabelToCTA","closest","getHeadersOutsideContainers","flatMap","R","I","_i$data","_u$data","m","ariaLabelCTASelector","document","body","getAttribute","logError","h","window","lana","log","tags","Promise","all","fetch","C","catch","json","prefix","locale","data","prefixes","addProductName","addHeader","hasAttribute"],"sourceRoot":""}