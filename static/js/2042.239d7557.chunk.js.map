{"version":3,"file":"static/js/2042.239d7557.chunk.js","mappings":"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","sources":["../node_modules/@adobecom/blocks/fragment/fragment.js"],"sourcesContent":["/* eslint-disable max-classes-per-file */\nimport { createTag, getConfig, loadArea, localizeLink, customFetch } from '../../utils/utils.js';\n\nconst fragMap = {};\n\nconst removeHash = (url) => {\n  const urlNoHash = url.split('#')[0];\n  return url.includes('#_dnt') ? `${urlNoHash}#_dnt` : urlNoHash;\n};\n\nconst isCircularRef = (href) => [...Object.values(fragMap)]\n  .some((tree) => {\n    const node = tree.find(href);\n    return node?.isRecursive;\n  });\n\nconst updateFragMap = (fragment, a, href) => {\n  const fragLinks = [...fragment.querySelectorAll('a')]\n    .filter((link) => localizeLink(link.href).includes('/fragments/'));\n  if (!fragLinks.length) return;\n\n  if (document.body.contains(a) && !a.parentElement?.closest('.fragment')) {\n    // eslint-disable-next-line no-use-before-define\n    fragMap[href] = new Tree(href);\n    fragLinks.forEach((link) => fragMap[href].insert(href, localizeLink(removeHash(link.href))));\n  } else {\n    Object.values(fragMap).forEach((tree) => {\n      const hrefNode = tree.find(href);\n      if (!hrefNode) return;\n\n      fragLinks.forEach((link) => {\n        const localizedHref = localizeLink(removeHash(link.href));\n        const parentNodeSameHref = hrefNode.findParent(localizedHref);\n        if (parentNodeSameHref) {\n          parentNodeSameHref.isRecursive = true;\n        } else {\n          hrefNode.addChild(localizedHref);\n        }\n      });\n    });\n  }\n};\n\nconst insertInlineFrag = async (sections, a, relHref) => {\n  // Inline fragments only support one section, other sections are ignored\n  const fragChildren = [...sections[0].children];\n  if (a.parentElement.nodeName === 'DIV' && !a.parentElement.attributes.length) {\n    a.parentElement.replaceWith(...fragChildren);\n  } else {\n    a.replaceWith(...fragChildren);\n  }\n  const promises = [];\n  fragChildren.forEach((child) => {\n    child.setAttribute('data-path', relHref);\n    if (child.querySelector('a[href*=\"/fragments/\"]')) promises.push(loadArea(child));\n  });\n  await Promise.all(promises);\n};\n\nfunction replaceDotMedia(path, doc) {\n  const resetAttributeBase = (tag, attr) => {\n    doc.querySelectorAll(`${tag}[${attr}^=\"./media_\"]`).forEach((el) => {\n      el[attr] = new URL(el.getAttribute(attr), new URL(path, window.location)).href;\n    });\n  };\n  resetAttributeBase('img', 'src');\n  resetAttributeBase('source', 'srcset');\n}\n\nexport default async function init(a) {\n  const { decorateArea, mep, placeholders, locale } = getConfig();\n  let relHref = localizeLink(a.href);\n  let inline = false;\n\n  if (a.parentElement?.nodeName === 'P') {\n    const children = a.parentElement.childNodes;\n    const div = createTag('div');\n    for (const attr of a.parentElement.attributes) div.setAttribute(attr.name, attr.value);\n    a.parentElement.replaceWith(div);\n    div.append(...children);\n  }\n\n  let mepFrag;\n  try {\n    const path = !a.href.includes('/federal/') ? new URL(a.href).pathname\n      : a.href.replace('#_inline', '').replace(locale.prefix, '');\n    mepFrag = mep?.fragments?.[path];\n  } catch (e) {\n    // do nothing\n  }\n  if (mepFrag) {\n    const { handleFragmentCommand } = await import('../../features/personalization/personalization.js');\n    relHref = handleFragmentCommand(mepFrag, a);\n    if (!relHref) return;\n  }\n\n  if (a.href.includes('#_inline')) {\n    inline = true;\n    a.href = a.href.replace('#_inline', '');\n    relHref = relHref.replace('#_inline', '');\n  }\n\n  if (isCircularRef(relHref)) {\n    window.lana?.log(`ERROR: Fragment Circular Reference loading ${a.href}`);\n    return;\n  }\n\n  let resourcePath = a.href;\n  if (a.href.includes('/federal/')) {\n    const { getFederatedUrl } = await import('../../utils/utils.js');\n    resourcePath = getFederatedUrl(a.href);\n  }\n  const resp = await customFetch({ resource: `${resourcePath}.plain.html`, withCacheRules: true })\n    .catch(() => ({}));\n\n  if (!resp?.ok) {\n    window.lana?.log(`Could not get fragment: ${resourcePath}.plain.html`);\n    return;\n  }\n\n  const html = await resp.text();\n  const doc = new DOMParser().parseFromString(html, 'text/html');\n  replaceDotMedia(a.href, doc);\n  if (decorateArea) decorateArea(doc, { fragmentLink: a });\n\n  const sections = doc.querySelectorAll('body > div');\n\n  if (!sections.length) {\n    window.lana?.log(`Could not make fragment: ${resourcePath}.plain.html`);\n    return;\n  }\n\n  const fragment = createTag('div', { class: 'fragment', 'data-path': relHref });\n  fragment.append(...sections);\n\n  updateFragMap(fragment, a, relHref);\n  if (a.dataset.manifestId\n    || a.dataset.adobeTargetTestid\n    || mep?.commands?.length\n    || placeholders) {\n    const { updateFragDataProps, handleCommands, replacePlaceholders } = await import('../../features/personalization/personalization.js');\n    if (a.dataset.manifestId || a.dataset.adobeTargetTestid) {\n      updateFragDataProps(a, inline, sections, fragment);\n    }\n    if (mep?.commands?.length) handleCommands(mep?.commands, fragment, false, true);\n    if (placeholders) fragment.innerHTML = replacePlaceholders(fragment.innerHTML, placeholders);\n  }\n  if (inline) {\n    await insertInlineFrag(sections, a, relHref, mep);\n  } else {\n    a.parentElement.replaceChild(fragment, a);\n    await loadArea(fragment);\n  }\n}\n\nclass Node {\n  constructor(key, value = key, parent = null) {\n    this.key = key;\n    this.value = value;\n    this.parent = parent;\n    this.children = [];\n    this.isRecursive = false;\n  }\n\n  addChild(key, value = key) {\n    const alreadyHasChild = this.children.some((n) => n.key === key);\n    if (!alreadyHasChild) {\n      this.children.push(new Node(key, value, this));\n    }\n  }\n\n  findParent(key) {\n    if (this.parent?.key === key) return this.parent;\n    return this.parent?.findParent(key);\n  }\n}\n\nexport class Tree {\n  constructor(key, value = key) {\n    this.root = new Node(key, value);\n  }\n\n  * traverse(node = this.root) {\n    yield node;\n    if (node.children.length) {\n      for (const child of node.children) {\n        yield* this.traverse(child);\n      }\n    }\n  }\n\n  insert(parentNodeKey, key, value = key) {\n    for (const node of this.traverse()) {\n      if (node.key === parentNodeKey) {\n        if (parentNodeKey === key) {\n          node.isRecursive = true;\n        } else {\n          node.children.push(new Node(key, value, node));\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  remove(key) {\n    for (const node of this.traverse()) {\n      const filtered = node.children.filter((c) => c.key !== key);\n      if (filtered.length !== node.children.length) {\n        node.children = filtered;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  find(key) {\n    for (const node of this.traverse()) {\n      if (node.key === key) return node;\n    }\n    return undefined;\n  }\n}\n"],"names":["p","A","e","t","split","includes","concat","H","Object","values","some","_t$find","find","isRecursive","P","updateFragMap","r","_t$parentElement","i","querySelectorAll","filter","n","h","href","length","document","body","contains","parentElement","closest","forEach","a","f","c","o","findParent","addChild","C","insert","L","async","children","nodeName","attributes","replaceWith","setAttribute","querySelector","push","E","Promise","all","M","_e$parentElement","_r$commands","decorateArea","mep","placeholders","locale","b","s","childNodes","d","v","m","name","value","append","_r$fragments","replace","prefix","URL","pathname","fragments","handleFragmentCommand","_window$lana","window","lana","log","getFederatedUrl","R","y","resource","withCacheRules","catch","_window$lana2","ok","F","text","w","DOMParser","parseFromString","resetAttributeBase","getAttribute","location","$","fragmentLink","u","_window$lana3","l","class","dataset","manifestId","adobeTargetTestid","commands","_r$commands2","updateFragDataProps","handleCommands","replacePlaceholders","innerHTML","replaceChild","g","constructor","arguments","undefined","this","key","parent","_this$parent","_this$parent2","root","traverse","_this","remove"],"sourceRoot":""}