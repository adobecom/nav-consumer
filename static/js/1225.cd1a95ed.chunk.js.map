{"version":3,"file":"static/js/1225.cd1a95ed.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js","../../milo/libs/utils/decorate.js","../../milo/libs/blocks/section-metadata/section-metadata.js","../../milo/libs/blocks/section-metadata/sticky-section.js"],"sourcesContent":["function _taggedTemplateLiteral(e, t) {\n  return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {\n    raw: {\n      value: Object.freeze(t)\n    }\n  }));\n}\nexport { _taggedTemplateLiteral as default };","import {\n  createTag,\n  loadStyle,\n  getConfig,\n  createIntersectionObserver,\n  getFederatedContentRoot,\n  getFedsPlaceholderConfig,\n  shouldBlockFreeTrialLinks,\n} from './utils.js';\n\nconst { miloLibs, codeRoot } = getConfig();\nconst HIDE_CONTROLS = '_hide-controls';\nlet firstVideo = null;\nlet videoLabels = {\n  playMotion: 'Play',\n  pauseMotion: 'Pause',\n  pauseIcon: 'Pause icon',\n  playIcon: 'Play icon',\n  hasFetched: false,\n};\nlet videoCounter = 0;\n\nexport function decorateButtons(el, size) {\n  const buttons = el.querySelectorAll('em a, strong a, p > a strong');\n  if (buttons.length === 0) return;\n  const buttonTypeMap = { STRONG: 'blue', EM: 'outline', A: 'blue' };\n  const localePrefix = getConfig()?.locale?.prefix;\n\n  buttons.forEach((button) => {\n    const parent = button.parentElement;\n    if (shouldBlockFreeTrialLinks({ button, localePrefix, parent })) return;\n    let target = button;\n    const buttonType = buttonTypeMap[parent.nodeName] || 'outline';\n    if (button.nodeName === 'STRONG') {\n      target = parent;\n    } else {\n      parent.insertAdjacentElement('afterend', button);\n      parent.remove();\n    }\n    target.classList.add('con-button', buttonType);\n    if (size) target.classList.add(size); /* button-l, button-xl */\n    const customClasses = target.href && [...target.href.matchAll(/#_button-([a-zA-Z-]+)/g)];\n    if (customClasses) {\n      customClasses.forEach((match) => {\n        target.href = target.href.replace(match[0], '');\n        if (target.dataset.modalHash) {\n          target.setAttribute('data-modal-hash', target.dataset.modalHash.replace(match[0], ''));\n        }\n        target.classList.add(match[1]);\n      });\n    }\n    const actionArea = button.closest('p, div');\n    if (actionArea) {\n      actionArea.classList.add('action-area');\n      actionArea.nextElementSibling?.classList.add('supplemental-text', 'body-xl');\n    }\n  });\n}\n\nexport function decorateIconStack(el) {\n  const ulElems = el.querySelectorAll('ul');\n  if (!ulElems.length) return;\n  const stackEl = ulElems[ulElems.length - 1];\n  stackEl.classList.add('icon-stack-area', 'body-s');\n  el.classList.add('icon-stack');\n  const items = stackEl.querySelectorAll('li');\n  [...items].forEach((i) => {\n    const links = i.querySelectorAll('a');\n    if (links.length <= 1) return;\n    const picIndex = links[0].querySelector('a picture') ? 0 : 1;\n    const linkImg = links[picIndex];\n    const linkText = links[1 - picIndex];\n    const linkPic = linkImg.querySelector('picture');\n    if (linkPic) {\n      linkText.prepend(linkPic);\n      linkImg.remove();\n    }\n  });\n}\n\nexport function decorateIconArea(el) {\n  const icons = el.querySelectorAll('.icon');\n  icons.forEach((icon) => {\n    icon.parentElement.classList.add('icon-area');\n    if (icon.textContent.includes('persona')) icon.parentElement.classList.add('persona-area');\n  });\n}\n\nfunction elContainsText(el) {\n  return [...el.childNodes].some(({ nodeType, innerText, textContent }) => (\n    (nodeType === Node.ELEMENT_NODE && innerText.trim() !== '')\n    || (nodeType === Node.TEXT_NODE && textContent.trim() !== '')\n  ));\n}\n\nexport function decorateBlockText(el, config = ['m', 's', 'm'], type = null) {\n  if (!el.classList.contains('default')) {\n    let headings = el?.querySelectorAll('h1, h2, h3, h4, h5, h6');\n    if (headings) {\n      if (type === 'hasDetailHeading' && headings.length > 1) headings = [...headings].splice(1);\n      headings.forEach((h) => h.classList.add(`heading-${config[0]}`));\n      if (config[2]) {\n        const prevSib = headings[0]?.previousElementSibling;\n        prevSib?.classList.toggle(`detail-${config[2]}`, !prevSib.querySelector('picture'));\n        decorateIconArea(el);\n      }\n    }\n    const bodyStyle = `body-${config[1]}`;\n    const emptyEls = el?.querySelectorAll(':is(p, ul, ol, div):not([class])');\n    if (emptyEls.length) {\n      [...emptyEls].filter(elContainsText).forEach((e) => e.classList.add(bodyStyle));\n    } else if (!el.classList.length && elContainsText(el)) {\n      el.classList.add(bodyStyle);\n    }\n  }\n  const buttonSize = config.length > 3 ? `button-${config[3]}` : '';\n  decorateButtons(el, buttonSize);\n  if (type === 'merch') decorateIconStack(el);\n}\n\nexport function handleFocalpoint(pic, child, removeChild) {\n  const image = pic.querySelector('img');\n  if (!child || !image) return;\n  let text = '';\n  if (child.childElementCount === 2) {\n    const dataElement = child.querySelectorAll('p')[1];\n    text = dataElement?.textContent;\n    if (removeChild) dataElement?.remove();\n  } else if (child.textContent) {\n    text = child.textContent;\n    const childData = child.childNodes;\n    if (removeChild) childData.forEach((c) => c.nodeType === Node.TEXT_NODE && c.remove());\n  }\n  if (!text) return;\n  const directions = text.trim().toLowerCase().split(',');\n  const [x, y = ''] = directions;\n  image.style.objectPosition = `${x} ${y}`;\n}\n\nexport async function decorateBlockBg(block, node, { useHandleFocalpoint = false, className = 'background' } = {}) {\n  const childCount = node.childElementCount;\n  if (node.querySelector('img, video, a[href*=\".mp4\"]') || childCount > 1) {\n    node.classList.add(className);\n    const binaryVP = [['mobile-only'], ['tablet-only', 'desktop-only']];\n    const allVP = [['mobile-only'], ['tablet-only'], ['desktop-only']];\n    const viewports = childCount === 2 ? binaryVP : allVP;\n    [...node.children].forEach((child, i) => {\n      if (childCount > 1 && i < viewports.length) child.classList.add(...viewports[i]);\n      const pic = child.querySelector('picture');\n      if (useHandleFocalpoint && pic\n        && (child.childElementCount === 2 || child.textContent?.trim())) {\n        handleFocalpoint(pic, child, true);\n      }\n      if (!child.querySelector('img, video, a[href*=\".mp4\"]')) {\n        child.style.background = child.textContent;\n        child.classList.add('expand-background');\n        child.textContent = '';\n      }\n    });\n  } else {\n    block.style.background = node.textContent;\n    node.remove();\n  }\n}\n\nexport function getBlockSize(el, defaultSize = 1) {\n  const sizes = ['small', 'medium', 'large', 'xlarge', 'medium-compact'];\n  if (defaultSize < 0 || defaultSize > sizes.length - 1) return null;\n  return sizes.find((size) => el.classList.contains(size)) || sizes[defaultSize];\n}\n\nexport const decorateBlockHrs = (el) => {\n  const pTags = el.querySelectorAll('p');\n  let hasHr = false;\n  const decorateHr = ((tag) => {\n    const hrTag = tag.textContent.trim().startsWith('---');\n    if (!hrTag) return;\n    hasHr = true;\n    const bgStyle = tag.textContent.substring(3).trim();\n    const hrElem = createTag('hr', { style: `background: ${bgStyle};` });\n    tag.textContent = '';\n    tag.appendChild(hrElem);\n  });\n  [...pTags].forEach((p) => {\n    decorateHr(p);\n  });\n  const singleElementInRow = el.children[0].childElementCount === 0;\n  if (singleElementInRow) {\n    decorateHr(el.children[0]);\n  }\n  if (hasHr) el.classList.add('has-divider');\n};\n\nfunction applyTextOverrides(el, override, targetEl) {\n  const parts = override.split('-');\n  const type = parts[1];\n  const scopeEl = (targetEl !== false) ? targetEl : el;\n  const els = scopeEl.querySelectorAll(`[class^=\"${type}\"]`);\n  if (!els.length) return;\n  els.forEach((elem) => {\n    const replace = [...elem.classList].find((i) => i.startsWith(type));\n    elem.classList.replace(replace, `${parts[1]}-${parts[0]}`);\n  });\n}\n\nexport function decorateTextOverrides(el, options = ['-heading', '-body', '-detail'], target = false) {\n  const overrides = [...el.classList]\n    .filter((elClass) => options.findIndex((ovClass) => elClass.endsWith(ovClass)) >= 0);\n  if (!overrides.length) return;\n  overrides.forEach((override) => {\n    applyTextOverrides(el, override, target);\n    el.classList.remove(override);\n  });\n}\n\nfunction defineDeviceByScreenSize() {\n  const screenWidth = window.innerWidth;\n  if (screenWidth <= 600) {\n    return 'mobile';\n  }\n  return 'desktop';\n}\n\nexport function getImgSrc(pic) {\n  let source = '';\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(pic, 'text/html');\n  if (defineDeviceByScreenSize() === 'mobile') source = doc.querySelector('source[type=\"image/webp\"]:not([media])');\n  else source = doc.querySelector('source[type=\"image/webp\"][media]');\n  return source?.srcset ? `poster='${source.srcset}'` : '';\n}\n\nexport function getVideoAttrs(hash, dataset) {\n  const isAutoplay = hash?.includes('autoplay');\n  const isAutoplayOnce = hash?.includes('autoplay1');\n  const playOnHover = hash?.includes('hoverplay');\n  const playInViewport = hash?.includes('viewportplay');\n  const poster = getImgSrc(dataset.videoPoster);\n  const globalAttrs = `playsinline ${poster}`;\n  const autoPlayAttrs = 'autoplay muted';\n  const playInViewportAttrs = playInViewport ? 'data-play-viewport' : '';\n\n  if (isAutoplay && !isAutoplayOnce) {\n    return `${globalAttrs} ${autoPlayAttrs} loop ${playInViewportAttrs}`;\n  }\n  if (playOnHover && isAutoplayOnce) {\n    return `${globalAttrs} ${autoPlayAttrs} data-hoverplay`;\n  }\n  if (playOnHover) {\n    return `${globalAttrs} muted data-hoverplay`;\n  }\n  if (isAutoplayOnce) {\n    return `${globalAttrs} ${autoPlayAttrs} ${playInViewportAttrs}`;\n  }\n  return `${globalAttrs} controls`;\n}\n\nexport function syncPausePlayIcon(video, event) {\n  if (!video.getAttributeNames().includes('data-hoverplay')) {\n    const offsetFiller = video.closest('.video-holder').querySelector('.offset-filler');\n    if (event?.type === 'playing' && offsetFiller?.classList.contains('is-playing')) return;\n    const anchorTag = video.closest('.video-holder').querySelector('a');\n    offsetFiller?.classList.toggle('is-playing');\n    const isPlaying = offsetFiller?.classList.contains('is-playing');\n    const indexOfVideo = (anchorTag.getAttribute('video-index') === '1' && videoCounter === 1) ? '' : anchorTag.getAttribute('video-index');\n    const changedLabel = `${isPlaying ? videoLabels?.pauseMotion : videoLabels?.playMotion}`;\n    const oldLabel = `${!isPlaying ? videoLabels?.pauseMotion : videoLabels?.playMotion}`;\n    const ariaLabel = `${changedLabel} ${indexOfVideo}`.trim();\n    anchorTag?.setAttribute('title', `${ariaLabel}`);\n    anchorTag?.setAttribute('aria-label', `${ariaLabel} `);\n    anchorTag?.setAttribute('aria-pressed', isPlaying ? 'true' : 'false');\n    const daaLL = anchorTag.getAttribute('daa-ll');\n    if (daaLL) anchorTag.setAttribute('daa-ll', daaLL.replace(oldLabel, changedLabel));\n  }\n}\n\nexport function addAccessibilityControl(videoString, videoAttrs, indexOfVideo, tabIndex = 0) {\n  if (videoAttrs.includes('controls')) return videoString;\n  const fedRoot = getFederatedContentRoot();\n  if (videoAttrs.includes('hoverplay')) {\n    return `<a class='pause-play-wrapper video-holder' tabindex=${tabIndex}>${videoString}</a>`;\n  }\n  return `\n    <div class='video-container video-holder'>${videoString}\n      <a class='pause-play-wrapper' title='${videoLabels.pauseMotion}' aria-label='${videoLabels.pauseMotion}' role='button' tabindex=${tabIndex} aria-pressed=true video-index=${indexOfVideo}>\n        <div class='offset-filler'>\n          <img class='accessibility-control pause-icon' alt='${videoLabels.pauseIcon}' src='${fedRoot}/federal/assets/svgs/accessibility-pause.svg'/>\n          <img class='accessibility-control play-icon' alt='${videoLabels.playIcon}' src='${fedRoot}/federal/assets/svgs/accessibility-play.svg'/>\n        </div>\n      </a>\n    </div>\n  `;\n}\n\nfunction isVideoReady(video) {\n  return video.readyState > 1;\n}\n\nexport function handlePause(event) {\n  event.stopPropagation();\n  if (event.code !== 'Enter' && event.code !== 'Space' && !['focus', 'click', 'blur'].includes(event.type)) {\n    return;\n  }\n  event.preventDefault();\n  const video = event.target.closest('.video-holder').parentElement.querySelector('video');\n  if (event.type === 'blur') {\n    video.pause();\n  } else if (video.paused || video.ended || event.type === 'focus') {\n    if (isVideoReady(video)) { video.play(); }\n  } else {\n    video.pause();\n  }\n  syncPausePlayIcon(video);\n}\n\nexport function applyHoverPlay(video) {\n  if (!video) return;\n  if (video.hasAttribute('data-hoverplay')) {\n    video.parentElement.addEventListener('focus', handlePause);\n    video.parentElement.addEventListener('blur', handlePause);\n    if (!video.hasAttribute('data-mouseevent')) {\n      video.addEventListener('mouseenter', () => { if (isVideoReady(video)) { video.play(); } });\n      video.addEventListener('mouseleave', () => { if (isVideoReady(video)) { video.pause(); } });\n      video.addEventListener('ended', () => { syncPausePlayIcon(video); });\n      video.setAttribute('data-mouseevent', true);\n    }\n  }\n}\n\nexport function applyAccessibilityEvents(videoEl) {\n  const pausePlayWrapper = videoEl.parentElement.querySelector('.pause-play-wrapper') || videoEl.closest('.pause-play-wrapper');\n  if (pausePlayWrapper?.querySelector('.accessibility-control')) {\n    pausePlayWrapper.addEventListener('click', handlePause);\n    pausePlayWrapper.addEventListener('keydown', handlePause);\n  }\n  if (videoEl.hasAttribute('autoplay')) {\n    videoEl.addEventListener('canplay', () => videoEl.play());\n    videoEl.addEventListener('playing', (event) => syncPausePlayIcon(videoEl, event));\n    videoEl.addEventListener('ended', () => syncPausePlayIcon(videoEl));\n  }\n}\n\nfunction setObjectFitAndPos(text, pic, bgEl, objFitOptions) {\n  const backgroundConfig = text.split(',').map((c) => c.toLowerCase().trim());\n  const fitOption = objFitOptions.filter((c) => backgroundConfig.includes(c));\n  const focusOption = backgroundConfig.filter((c) => !fitOption.includes(c));\n  if (fitOption) [pic.querySelector('img').style.objectFit] = fitOption;\n  bgEl.innerHTML = '';\n  bgEl.append(pic);\n  bgEl.append(document.createTextNode(focusOption.join(',')));\n}\n\nexport function handleObjectFit(bgRow) {\n  const bgConfig = bgRow.querySelectorAll('div');\n  [...bgConfig].forEach((r) => {\n    const pic = r.querySelector('picture');\n    if (!pic) return;\n    let text = '';\n    const pchild = [...r.querySelectorAll('p:not(:empty)')].filter((p) => p.innerHTML.trim() !== '');\n    if (pchild.length > 2) text = pchild[1]?.textContent.trim();\n    if (!text && r.textContent) text = r.textContent;\n    if (!text) return;\n    setObjectFitAndPos(text, pic, r, ['fill', 'contain', 'cover', 'none', 'scale-down']);\n  });\n}\n\nfunction getVideoIntersectionObserver() {\n  if (!window?.videoIntersectionObs) {\n    window.videoIntersectionObs = new window.IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        const { intersectionRatio, target: video } = entry;\n        const isHaveLoopAttr = video.getAttributeNames().includes('loop');\n        const { playedOnce = false } = video.dataset;\n        const isPlaying = video.currentTime > 0 && !video.paused && !video.ended\n          && video.readyState > video.HAVE_CURRENT_DATA;\n\n        if (intersectionRatio <= 0.8) {\n          video.pause();\n        } else if ((isHaveLoopAttr || !playedOnce) && !isPlaying) {\n          video.play();\n        }\n      });\n    }, { threshold: [0.8] });\n  }\n  return window.videoIntersectionObs;\n}\n\nfunction applyInViewPortPlay(video) {\n  if (!video) return;\n  if (video.hasAttribute('data-play-viewport')) {\n    const observer = getVideoIntersectionObserver();\n    video.addEventListener('ended', () => {\n      video.dataset.playedOnce = true;\n    });\n    observer.observe(video);\n  }\n}\n\nexport function decorateMultiViewport(el) {\n  const foreground = el.querySelector('.foreground');\n  const cols = foreground.childElementCount;\n  if (cols === 2 || cols === 3) {\n    const viewports = [\n      '(max-width: 599px)',\n      '(min-width: 600px) and (max-width: 1199px)',\n      '(min-width: 1200px)',\n      '(min-width: 600px)',\n    ].filter((v, i) => (cols === 2 ? [0, 3].includes(i) : i !== 3));\n    [...foreground.children].forEach((child, index) => {\n      const mq = window.matchMedia(viewports[index]);\n      const setContent = () => mq.matches && foreground.replaceChildren(child);\n      setContent();\n      mq.addEventListener('change', setContent);\n    });\n  }\n  return foreground;\n}\n\nexport async function loadCDT(el, classList) {\n  try {\n    await Promise.all([\n      loadStyle(`${miloLibs || codeRoot}/features/cdt/cdt.css`),\n      import('../features/cdt/cdt.js')\n        .then(({ default: initCDT }) => initCDT(el, classList)),\n    ]);\n  } catch (error) {\n    window.lana?.log(`WARN: Failed to load countdown timer: ${error}`, { tags: 'errorType=warn,module=countdown-timer' });\n  }\n}\n\nexport function isVideoAccessible(anchorTag) {\n  return !anchorTag?.hash.includes(HIDE_CONTROLS);\n}\n\nfunction updateFirstVideo() {\n  if (firstVideo != null && firstVideo?.controls === false && videoCounter > 1) {\n    let videoHolder = document.querySelector('[video-index=\"1\"]') || firstVideo.closest('.video-holder');\n    if (videoHolder.nodeName !== 'A') videoHolder = videoHolder.querySelector('a.pause-play-wrapper');\n    const firstVideoLabel = videoHolder.getAttribute('aria-label');\n    videoHolder.setAttribute('aria-label', `${firstVideoLabel} 1`);\n    firstVideo = null;\n  }\n}\n\nfunction updateAriaLabel(videoEl, videoAttrs) {\n  if (!videoEl.getAttributeNames().includes('data-hoverplay')) {\n    const pausePlayWrapper = videoEl.parentElement.querySelector('.pause-play-wrapper') || videoEl.closest('.pause-play-wrapper');\n    const pauseIcon = pausePlayWrapper.querySelector('.pause-icon');\n    const playIcon = pausePlayWrapper.querySelector('.play-icon');\n    const indexOfVideo = pausePlayWrapper.getAttribute('video-index');\n    let ariaLabel = `${videoAttrs.includes('autoplay') ? videoLabels.pauseMotion : videoLabels.playMotion}`;\n    ariaLabel = ariaLabel.concat(` ${indexOfVideo === '1' && videoCounter === 1 ? '' : indexOfVideo}`);\n    pausePlayWrapper.setAttribute('aria-label', ariaLabel);\n    pauseIcon.setAttribute('alt', videoLabels.pauseMotion);\n    playIcon.setAttribute('alt', videoLabels.playMotion);\n    updateFirstVideo();\n  }\n}\n\nexport function decoratePausePlayWrapper(videoEl, videoAttrs) {\n  if (!videoLabels.hasFetched) {\n    import('../features/placeholders.js').then(({ replaceKeyArray }) => {\n      replaceKeyArray(['pause-motion', 'play-motion', 'pause-icon', 'play-icon'], getFedsPlaceholderConfig())\n        .then(([pauseMotion, playMotion, pauseIcon, playIcon]) => {\n          videoLabels = { playMotion, pauseMotion, pauseIcon, playIcon };\n          videoLabels.hasFetched = true;\n          updateAriaLabel(videoEl, videoAttrs);\n        });\n    });\n  } else {\n    updateAriaLabel(videoEl, videoAttrs);\n  }\n}\n\nexport function decorateAnchorVideo({ src = '', anchorTag }) {\n  if (!src.length || !(anchorTag instanceof HTMLElement)) return;\n  const accessibilityEnabled = isVideoAccessible(anchorTag);\n  anchorTag.hash = anchorTag.hash.replace(`#${HIDE_CONTROLS}`, '');\n  if (anchorTag.closest('.marquee, .aside, .hero-marquee, .quiz-marquee') && !anchorTag.hash) anchorTag.hash = '#autoplay';\n  const { dataset, parentElement } = anchorTag;\n  const attrs = getVideoAttrs(anchorTag.hash, dataset);\n  const tabIndex = anchorTag.tabIndex || 0;\n  const videoIndex = (tabIndex === -1) ? 'tabindex=-1' : '';\n  let video = `<video ${attrs} data-video-source=${src} ${videoIndex}></video>`;\n  if (!attrs.includes('controls') && !attrs.includes('hoverplay') && accessibilityEnabled) {\n    videoCounter += 1;\n  }\n  const indexOfVideo = videoCounter;\n  if (accessibilityEnabled) {\n    video = addAccessibilityControl(video, attrs, indexOfVideo, tabIndex);\n  }\n  anchorTag.insertAdjacentHTML('afterend', video);\n  const videoEl = parentElement.querySelector('video');\n  if (indexOfVideo === 1) {\n    firstVideo = videoEl;\n  }\n\n  createIntersectionObserver({\n    el: videoEl,\n    options: { rootMargin: '1000px' },\n    callback: () => {\n      if (videoEl.querySelector('source')) return;\n      videoEl.appendChild(createTag('source', { src, type: 'video/mp4' }));\n    },\n  });\n\n  if (videoEl.controls) {\n    const io = new IntersectionObserver((entries) => {\n      entries.forEach(({ isIntersecting, target }) => {\n        if (!isIntersecting && !target.paused) target.pause();\n      });\n    }, { rootMargin: '0px' });\n    io.observe(videoEl);\n  }\n\n  if (accessibilityEnabled) {\n    applyAccessibilityEvents(videoEl);\n    if (!videoEl.controls) {\n      decoratePausePlayWrapper(videoEl, attrs);\n    }\n  }\n  applyHoverPlay(videoEl);\n  applyInViewPortPlay(videoEl);\n  anchorTag.remove();\n}\n","import { handleFocalpoint } from '../../utils/decorate.js';\n\nexport function handleBackground(div, section) {\n  const pic = div.background.content?.querySelector('picture');\n  if (pic) {\n    section.classList.add('has-background');\n    pic.classList.add('section-background');\n    handleFocalpoint(pic, div.background.content);\n    section.insertAdjacentElement('afterbegin', pic);\n  } else {\n    const color = div.background.content?.textContent;\n    if (color) {\n      section.style.background = color;\n    }\n  }\n}\n\nexport async function handleStyle(text, section) {\n  if (!text || !section) return;\n  const styles = text.split(', ').map((style) => style.replaceAll(' ', '-'));\n  const sticky = styles.find((style) => style === 'sticky-top' || style === 'sticky-bottom');\n  if (sticky) {\n    const { default: handleStickySection } = await import('./sticky-section.js');\n    await handleStickySection(sticky, section);\n  }\n  if (styles.includes('masonry')) styles.push('masonry-up');\n  section.classList.add(...styles);\n}\n\nfunction handleMasonry(text, section) {\n  section.classList.add(...['masonry-layout', 'masonry-up']);\n  const divs = section.querySelectorAll(\":scope > div:not([class*='metadata'])\");\n  const spans = [];\n  text.split('\\n').forEach((line) => spans.push(...line.trim().split(',')));\n  [...divs].forEach((div, i) => {\n    const spanWidth = spans[i] ? spans[i] : 'span 4';\n    div.classList.add(`grid-${spanWidth.trim().replace(' ', '-')}`);\n  });\n}\n\nfunction handleLayout(text, section) {\n  if (!(text || section)) return;\n  const layoutClass = `grid-template-columns-${text.replaceAll(' | ', '-')}`;\n  section.classList.add(layoutClass);\n}\n\nexport function getDelayTime(time) {\n  if (time > 99) return time;\n  return (time * 1000);\n}\n\nfunction handleDelay(time, section) {\n  if (!(time || section)) return;\n  section.classList.add('hide-sticky-section');\n  setTimeout(() => { section.classList.remove('hide-sticky-section'); }, getDelayTime(time));\n}\n\nfunction handleAnchor(anchor, section) {\n  if (!anchor || !section) return;\n  section.id = anchor.toLowerCase().trim().replaceAll(/\\s+/g, '-');\n  section.classList.add('section-anchor');\n}\n\nexport const getMetadata = (el) => [...el.childNodes].reduce((rdx, row) => {\n  if (row.children) {\n    const key = row.children[0].textContent.trim().toLowerCase();\n    const content = row.children[1];\n    const text = content.textContent.trim().toLowerCase();\n    if (key && content) rdx[key] = { content, text };\n  }\n  return rdx;\n}, {});\n\nexport default async function init(el) {\n  const section = el.closest('.section');\n  const metadata = getMetadata(el);\n  if (metadata.style) await handleStyle(metadata.style.text, section);\n  if (metadata.background) handleBackground(metadata, section);\n  if (metadata.layout) handleLayout(metadata.layout.text, section);\n  if (metadata.masonry) handleMasonry(metadata.masonry.text, section);\n  if (metadata.delay) handleDelay(metadata.delay.text, section);\n  if (metadata.anchor) handleAnchor(metadata.anchor.text, section);\n}\n","import { createTag } from '../../utils/utils.js';\nimport { getMetadata, getDelayTime } from './section-metadata.js';\nimport { getGnavHeight } from '../global-navigation/utilities/utilities.js';\n\nfunction handleTopHeight(section) {\n  const topHeight = getGnavHeight();\n  section.style.top = `${topHeight}px`;\n}\n\nfunction promoIntersectObserve(el, stickySectionEl, options = {}) {\n  const io = new IntersectionObserver((entries, observer) => {\n    entries.forEach((entry) => {\n      if (el.classList.contains('close-sticky-section')) {\n        window.removeEventListener('resize', handleTopHeight);\n        observer.unobserve(entry.target);\n        return;\n      }\n\n      const abovePromoStart = (entry.target === stickySectionEl && entry.isIntersecting)\n        || stickySectionEl?.getBoundingClientRect().y > 0;\n\n      if (entry.target === document.querySelector('footer')) {\n        el.classList.toggle('fill-sticky-section', entry.isIntersecting);\n      } else el.classList.toggle('hide-sticky-section', abovePromoStart);\n    });\n  }, options);\n  return io;\n}\n\nfunction handleStickyPromobar(section, delay) {\n  const main = document.querySelector('main');\n  section.classList.add('promo-sticky-section', 'hide-sticky-section');\n  if (section.querySelector('.popup:is(.promobar)')) section.classList.add('popup');\n  let stickySectionEl = null;\n  let hasScrollControl;\n  if ((section.querySelector(':is(.promobar, .notification)').classList.contains('no-delay'))\n    || (delay && section.classList.contains('popup'))) {\n    hasScrollControl = true;\n    section.classList.remove('hide-sticky-section');\n  }\n  if (!hasScrollControl && main.children[0] !== section) {\n    stickySectionEl = createTag('div', { class: 'section show-sticky-section' });\n    section.parentElement.insertBefore(stickySectionEl, section);\n  }\n  const io = promoIntersectObserve(section, stickySectionEl);\n  if (stickySectionEl) io.observe(stickySectionEl);\n  if (section.querySelector(':is(.promobar, .notification)')) {\n    io.observe(document.querySelector('footer'));\n  }\n}\n\nexport default async function handleStickySection(sticky, section) {\n  const main = document.querySelector('main');\n  switch (sticky) {\n    case 'sticky-top': {\n      const { debounce } = await import('../../utils/action.js');\n      window.addEventListener('resize', debounce(() => handleTopHeight(section)));\n      handleTopHeight(section);\n      main.prepend(section);\n      break;\n    }\n    case 'sticky-bottom': {\n      if (section.querySelector(':is(.promobar, .notification)')) {\n        const metadata = getMetadata(section.querySelector('.section-metadata'));\n        const delay = getDelayTime(metadata.delay?.text);\n        if (delay) setTimeout(() => { handleStickyPromobar(section, delay); }, delay);\n        else handleStickyPromobar(section, delay);\n      }\n      main.append(section);\n      break;\n    }\n    default:\n      break;\n  }\n}\n"],"names":["_taggedTemplateLiteral","e","t","slice","Object","freeze","defineProperties","raw","value","miloLibs","q","codeRoot","k","c","p","n","_n$background$content","background","content","querySelector","classList","add","s","o","childElementCount","r","querySelectorAll","textContent","remove","childNodes","forEach","l","nodeType","Node","TEXT_NODE","a","trim","toLowerCase","split","i","u","style","objectPosition","concat","d","insertAdjacentElement","_n$background$content2","f","map","replaceAll","find","default","includes","push","h","x","reduce","children","text","L","closest","layout","m","masonry","replace","y","delay","setTimeout","b","anchor","id","g","top","document","contains","class","parentElement","insertBefore","IntersectionObserver","window","removeEventListener","unobserve","target","isIntersecting","getBoundingClientRect","toggle","arguments","length","undefined","observe","debounce","addEventListener","prepend","_o$delay","append"],"sourceRoot":""}