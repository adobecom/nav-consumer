{"version":3,"file":"static/js/4669.6984dd51.chunk.js","mappings":"yKAQO,SAASA,EAAiBC,EAASC,EAAWC,GAIzB,IAHPF,EAEhBG,QAAQC,KAAYH,EAAUI,IAAMD,EAAME,OAASL,EAAUK,MAAQF,EAAMC,OAC/DE,QAAgBP,EAAQO,OAASL,GAE9CF,EAAQQ,KAAKP,EAEjB,CASA,eAAOQ,EAAiCT,EAAMC,GAAwB,IAAdC,EAAAQ,UAAAH,OAAA,QAAAI,IAAAD,UAAA,GAAAA,UAAA,GAAQ,IACxDE,EAAsB,CAAC,KAAM,KAAM,KAAM,KAAM,MAAMC,SAASZ,GAC9DG,EAAcU,SAASC,cAAc,QACrCC,QAAaC,MAAA,GAAAC,OAASlB,EAAI,WAAAkB,OAAUhB,IAC1C,IAAME,IAAeY,EAAKG,GAAK,OAC/B,IAAMC,QAAaJ,EAAKK,OAClBC,EAAclB,EAAYmB,YAAYC,cAEtCC,EAAerB,EAAYsB,iBAAiB,KAAKnB,OACjDoB,EAAeL,EAAYM,MAAM,MAAMrB,OAG7C,GAFkBsB,KAAKC,MAAMH,EAAe,KAAQF,GAEpC,EAAG,OACnB,IAAMM,EAAanB,EAAsB,GAAK,MACxCoB,GAAYC,MAAMC,QAAQd,GAAQA,EAAOA,EAAKe,MAEjDhC,QAAOiC,IAAA,IAAGC,QAAAC,GAAQF,EAAA,OAAsD,IAAhDd,EAAYiB,QAAQD,EAAQd,cAAqB,IAEzEgB,MAAK,CAACF,EAAGG,IAAMA,EAAEJ,QAAQ9B,OAAS+B,EAAED,QAAQ9B,SAE5CmC,KAAKJ,IAAA,CACJK,OAAQ,IAAIC,OAAA,GAAA1B,OAAUa,EAAU,KAAAb,OAAIoB,EAAKD,QAAQQ,QAAQ,uBAAwB,QAAO,KAAA3B,OAAIa,GAAc,SACvGO,MAGiB,IAApBN,EAASzB,QAEbH,EACGsB,iBAAiB,wBACjBoB,SAASR,IAER,IAAMG,EAAYH,EAAEZ,iBAAiB,KAAKnB,OACpCwC,EAAYT,EAAEf,YAAYK,MAAM,MAAMrB,OACtCyC,EAAenB,KAAKC,MAAMiB,EAAY,IAAMN,GAC9C7B,GAAuBoC,EAAe,IACxCf,MAAMgB,KAAKX,EAAEY,YAEV/C,QAAQgD,GAASA,EAAKC,WAAaC,KAAKC,YACxCR,SAASK,IACR,IAAMI,EAAU,GAEhBvB,EAASc,SAASU,IAChB,IAAMC,EAAQD,EAAKb,OAAOe,KAAKP,EAASQ,WACpCF,GACF1D,EAAiBwD,EAAS,CACxBK,KAAAJ,EACAlD,MAAOmD,EAAMI,MACbxD,IAAKoD,EAAMI,MAAQL,EAAKnB,QAAQ9B,QAC/ByC,EAEP,IACAO,EAEGf,MAAK,CAACgB,EAAGC,IAAMA,EAAEnD,MAAQkD,EAAElD,QAE3BwC,SAAQgB,IAA0B,IAAvBF,KAAAJ,EAAMlD,MAAAmD,EAAOpD,IAAA0D,GAAID,EACrBE,EAAOb,EAASQ,UAChBM,EAAInD,SAASoD,cAAc,KACjCD,EAAEE,MAAQX,EAAKnB,QACf4B,EAAEG,KAAOZ,EAAKa,IACdJ,EAAEK,aAAa,cAAe,aAC9BL,EAAEK,aAAa,YAAApD,OAAa+C,EAAEE,MAAK,mBAAAjD,OAAkBsC,EAAKnB,UAC1D4B,EAAEM,YAAYzD,SAAS0D,eAAeR,EAAKS,UAAUhB,EAAOM,KAC5DzB,EAAEoC,aAAaT,EAAGd,EAASwB,aAC3BrC,EAAEoC,aAAa5D,SAAS0D,eAAeR,EAAKS,UAAUV,IAAOE,EAAEU,aAC/DxB,EAASQ,UAAYK,EAAKS,UAAU,EAAGhB,GAEvCzB,EAAS4C,OAAO5C,EAASO,QAAQiB,GAAO,EAC1C,GACJ,GAEN,GACJ,C","sources":["../node_modules/@adobecom/features/interlinks.js"],"sourcesContent":["/**\n * Checks if a given match intersects with an existing match\n * before adding it to the list of matches. In case of an\n * intersection, the more specific (i.e. longer) match wins.\n * @param {array} matches The existing matches\n * @param {object} contender The match to check and add\n * @param {number} maxMatches The maximum number of matches\n */\nexport function checkAndAddMatch(matches, contender, maxMatches) {\n  const collisions = matches\n    // check for intersections\n    .filter((match) => !(contender.end < match.start || contender.start > match.end));\n  if (collisions.length === 0 && matches.length < maxMatches) {\n    // no intersecting existing matches, add contender if max not yet reached\n    matches.push(contender);\n  }\n}\n\n/**\n * Loops through a list of keywords and looks for matches in the article text.\n * The first occurrence of each keyword will be replaced with a link and tracking added.\n * The keywords file must have a column titled \"Keyword\".\n * @param {string} path The location of the keywords file to be used for interlinks.\n * @param {number} limit The maximum amount of keywords to fetch from the file.  Default is 1000.\n */\nexport default async function interlink(path, language, limit = 1000) {\n  const isExceptionLanguage = ['zh', 'ko', 'ja', 'th', 'he'].includes(language);\n  const articleBody = document.querySelector('main');\n  const resp = await fetch(`${path}?limit=${limit}`);\n  if (!(articleBody && resp.ok)) return;\n  const json = await resp.json();\n  const articleText = articleBody.textContent.toLowerCase();\n  // set article link limit: 1 every 100 words\n  const articleLinks = articleBody.querySelectorAll('a').length;\n  const articleWords = articleText.split(/\\s/).length;\n  const maxLinks = (Math.floor(articleWords / 100)) - articleLinks;\n  // eslint-disable-next-line no-useless-return\n  if (maxLinks <= 0) return;\n  const wordBorder = isExceptionLanguage ? '' : '\\\\b';\n  const keywords = (Array.isArray(json) ? json : json.data)\n    // scan article to filter keywords down to relevant ones\n    .filter(({ Keyword }) => articleText.indexOf(Keyword.toLowerCase()) !== -1)\n    // sort matches by length descending\n    .sort((a, b) => b.Keyword.length - a.Keyword.length)\n    // prepare regexps\n    .map((item) => ({\n      regexp: new RegExp(`${wordBorder}(${item.Keyword.replace(/[/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')})${wordBorder}`, 'iu'),\n      ...item,\n    }));\n  // eslint-disable-next-line no-useless-return\n  if (keywords.length === 0) return;\n  // find exact text node matches and insert links\n  articleBody\n    .querySelectorAll('div > p:not([class])')\n    .forEach((p) => {\n      // set paragraph link limit: 1 every 40 words\n      const paraLinks = p.querySelectorAll('a').length;\n      const paraWords = p.textContent.split(/\\s/).length;\n      const maxParaLinks = Math.floor(paraWords / 40) - paraLinks;\n      if (isExceptionLanguage || maxParaLinks > 0) {\n        Array.from(p.childNodes)\n        // filter out non text nodes\n          .filter((node) => node.nodeType === Node.TEXT_NODE)\n          .forEach((textNode) => {\n            const matches = [];\n            // find case-insensitive matches inside text node\n            keywords.forEach((item) => {\n              const match = item.regexp.exec(textNode.nodeValue);\n              if (match) {\n                checkAndAddMatch(matches, {\n                  item,\n                  start: match.index,\n                  end: match.index + item.Keyword.length,\n                }, maxParaLinks);\n              }\n            });\n            matches\n            // sort matches by start index descending\n              .sort((a, b) => b.start - a.start)\n            // split text node, insert link with matched text, and add link tracking\n              .forEach(({ item, start, end }) => {\n                const text = textNode.nodeValue;\n                const a = document.createElement('a');\n                a.title = item.Keyword;\n                a.href = item.URL;\n                a.setAttribute('data-origin', 'interlink');\n                a.setAttribute('daa-ll', `${a.title}--interlinks_p_${item.Keyword}`);\n                a.appendChild(document.createTextNode(text.substring(start, end)));\n                p.insertBefore(a, textNode.nextSibling);\n                p.insertBefore(document.createTextNode(text.substring(end)), a.nextSibling);\n                textNode.nodeValue = text.substring(0, start);\n                // remove matched link from interlinks\n                keywords.splice(keywords.indexOf(item), 1);\n              });\n          });\n      }\n    });\n}\n"],"names":["$","i","a","c","filter","o","end","start","length","push","b","arguments","undefined","d","includes","document","querySelector","g","fetch","concat","ok","u","json","x","textContent","toLowerCase","A","querySelectorAll","E","split","Math","floor","y","l","Array","isArray","data","_ref","Keyword","e","indexOf","sort","f","map","regexp","RegExp","replace","forEach","L","p","from","childNodes","s","nodeType","Node","TEXT_NODE","w","t","n","exec","nodeValue","item","index","_ref2","k","h","r","createElement","title","href","URL","setAttribute","appendChild","createTextNode","substring","insertBefore","nextSibling","splice"],"sourceRoot":""}