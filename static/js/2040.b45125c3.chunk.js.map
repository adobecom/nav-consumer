{"version":3,"file":"static/js/2040.b45125c3.chunk.js","mappings":"yKAQO,SAASA,EAAiBC,EAASC,EAAWC,GAIzB,IAHPF,EAEhBG,QAAQC,KAAYH,EAAUI,IAAMD,EAAME,OAASL,EAAUK,MAAQF,EAAMC,OAC/DE,QAAgBP,EAAQO,OAASL,GAE9CF,EAAQQ,KAAKP,EAEjB,CASA,eAAOQ,EAAiCC,EAAMC,GAAwB,IAAdC,EAAAC,UAAAN,OAAA,QAAAO,IAAAD,UAAA,GAAAA,UAAA,GAAQ,IAC9D,MAAME,EAAsB,CAAC,KAAM,KAAM,KAAM,KAAM,MAAMC,SAASL,GAC9DM,EAAcC,SAASC,cAAc,QACrCC,QAAaC,MAAA,GAAAC,OAASZ,EAAI,WAAAY,OAAUV,IAC1C,IAAMK,IAAeG,EAAKG,GAAK,OAC/B,MAAMC,QAAaJ,EAAKI,OAClBC,EAAcR,EAAYS,YAAYC,cAEtCC,EAAeX,EAAYY,iBAAiB,KAAKtB,OACjDuB,EAAeL,EAAYM,MAAM,MAAMxB,OAG7C,GAFkByB,KAAKC,MAAMH,EAAe,KAAQF,GAEpC,EAAG,OACnB,MAAMM,EAAanB,EAAsB,GAAK,MACxCoB,GAAYC,MAAMC,QAAQb,GAAQA,EAAOA,EAAKc,MAEjDnC,QAAOoC,IAAA,IAAC,QAAEC,GAAQD,EAAA,OAAsD,IAAhDd,EAAYgB,QAAQD,EAAQb,cAAqB,IAEzEe,MAAK,CAACC,EAAGC,IAAMA,EAAEJ,QAAQjC,OAASoC,EAAEH,QAAQjC,SAE5CsC,KAAKC,IAAA,CACJC,OAAQ,IAAIC,OAAA,GAAA1B,OAAUY,EAAU,KAAAZ,OAAIwB,EAAKN,QAAQS,QAAQ,uBAAwB,QAAO,KAAA3B,OAAIY,GAAc,SACvGY,MAGiB,IAApBX,EAAS5B,QAEbU,EACGY,iBAAiB,wBACjBqB,SAASC,IAER,MAAMC,EAAYD,EAAEtB,iBAAiB,KAAKtB,OACpC8C,EAAYF,EAAEzB,YAAYK,MAAM,MAAMxB,OACtC+C,EAAetB,KAAKC,MAAMoB,EAAY,IAAMD,GAC9CrC,GAAuBuC,EAAe,IACxClB,MAAMmB,KAAKJ,EAAEK,YAEVrD,QAAQsD,GAASA,EAAKC,WAAaC,KAAKC,YACxCV,SAASW,IACR,MAAM7D,EAAU,GAEhBmC,EAASe,SAASJ,IAChB,MAAM1C,EAAQ0C,EAAKC,OAAOe,KAAKD,EAASE,WACpC3D,GACFL,EAAiBC,EAAS,CACxB8C,OACAxC,MAAOF,EAAM4D,MACb3D,IAAKD,EAAM4D,MAAQlB,EAAKN,QAAQjC,QAC/B+C,EACL,IAEFtD,EAEG0C,MAAK,CAACC,EAAGC,IAAMA,EAAEtC,MAAQqC,EAAErC,QAE3B4C,SAAQe,IAA0B,IAAzB,KAAEnB,EAAA,MAAMxC,EAAA,IAAOD,GAAI4D,EAC3B,MAAMC,EAAOL,EAASE,UAChBpB,EAAIzB,SAASiD,cAAc,KACjCxB,EAAEyB,MAAQtB,EAAKN,QACfG,EAAE0B,KAAOvB,EAAKwB,IACd3B,EAAE4B,aAAa,cAAe,aAC9B5B,EAAE4B,aAAa,YAAAjD,OAAaqB,EAAEyB,MAAK,mBAAA9C,OAAkBwB,EAAKN,UAC1DG,EAAE6B,YAAYtD,SAASuD,eAAeP,EAAKQ,UAAUpE,EAAOD,KAC5D8C,EAAEwB,aAAahC,EAAGkB,EAASe,aAC3BzB,EAAEwB,aAAazD,SAASuD,eAAeP,EAAKQ,UAAUrE,IAAOsC,EAAEiC,aAC/Df,EAASE,UAAYG,EAAKQ,UAAU,EAAGpE,GAEvC6B,EAAS0C,OAAO1C,EAASM,QAAQK,GAAO,EAAE,GAC1C,GAEV,GAEN,C","sources":["../node_modules/@adobecom/features/interlinks.js"],"sourcesContent":["/**\n * Checks if a given match intersects with an existing match\n * before adding it to the list of matches. In case of an\n * intersection, the more specific (i.e. longer) match wins.\n * @param {array} matches The existing matches\n * @param {object} contender The match to check and add\n * @param {number} maxMatches The maximum number of matches\n */\nexport function checkAndAddMatch(matches, contender, maxMatches) {\n  const collisions = matches\n    // check for intersections\n    .filter((match) => !(contender.end < match.start || contender.start > match.end));\n  if (collisions.length === 0 && matches.length < maxMatches) {\n    // no intersecting existing matches, add contender if max not yet reached\n    matches.push(contender);\n  }\n}\n\n/**\n * Loops through a list of keywords and looks for matches in the article text.\n * The first occurrence of each keyword will be replaced with a link and tracking added.\n * The keywords file must have a column titled \"Keyword\".\n * @param {string} path The location of the keywords file to be used for interlinks.\n * @param {number} limit The maximum amount of keywords to fetch from the file.  Default is 1000.\n */\nexport default async function interlink(path, language, limit = 1000) {\n  const isExceptionLanguage = ['zh', 'ko', 'ja', 'th', 'he'].includes(language);\n  const articleBody = document.querySelector('main');\n  const resp = await fetch(`${path}?limit=${limit}`);\n  if (!(articleBody && resp.ok)) return;\n  const json = await resp.json();\n  const articleText = articleBody.textContent.toLowerCase();\n  // set article link limit: 1 every 100 words\n  const articleLinks = articleBody.querySelectorAll('a').length;\n  const articleWords = articleText.split(/\\s/).length;\n  const maxLinks = (Math.floor(articleWords / 100)) - articleLinks;\n  // eslint-disable-next-line no-useless-return\n  if (maxLinks <= 0) return;\n  const wordBorder = isExceptionLanguage ? '' : '\\\\b';\n  const keywords = (Array.isArray(json) ? json : json.data)\n    // scan article to filter keywords down to relevant ones\n    .filter(({ Keyword }) => articleText.indexOf(Keyword.toLowerCase()) !== -1)\n    // sort matches by length descending\n    .sort((a, b) => b.Keyword.length - a.Keyword.length)\n    // prepare regexps\n    .map((item) => ({\n      regexp: new RegExp(`${wordBorder}(${item.Keyword.replace(/[/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')})${wordBorder}`, 'iu'),\n      ...item,\n    }));\n  // eslint-disable-next-line no-useless-return\n  if (keywords.length === 0) return;\n  // find exact text node matches and insert links\n  articleBody\n    .querySelectorAll('div > p:not([class])')\n    .forEach((p) => {\n      // set paragraph link limit: 1 every 40 words\n      const paraLinks = p.querySelectorAll('a').length;\n      const paraWords = p.textContent.split(/\\s/).length;\n      const maxParaLinks = Math.floor(paraWords / 40) - paraLinks;\n      if (isExceptionLanguage || maxParaLinks > 0) {\n        Array.from(p.childNodes)\n        // filter out non text nodes\n          .filter((node) => node.nodeType === Node.TEXT_NODE)\n          .forEach((textNode) => {\n            const matches = [];\n            // find case-insensitive matches inside text node\n            keywords.forEach((item) => {\n              const match = item.regexp.exec(textNode.nodeValue);\n              if (match) {\n                checkAndAddMatch(matches, {\n                  item,\n                  start: match.index,\n                  end: match.index + item.Keyword.length,\n                }, maxParaLinks);\n              }\n            });\n            matches\n            // sort matches by start index descending\n              .sort((a, b) => b.start - a.start)\n            // split text node, insert link with matched text, and add link tracking\n              .forEach(({ item, start, end }) => {\n                const text = textNode.nodeValue;\n                const a = document.createElement('a');\n                a.title = item.Keyword;\n                a.href = item.URL;\n                a.setAttribute('data-origin', 'interlink');\n                a.setAttribute('daa-ll', `${a.title}--interlinks_p_${item.Keyword}`);\n                a.appendChild(document.createTextNode(text.substring(start, end)));\n                p.insertBefore(a, textNode.nextSibling);\n                p.insertBefore(document.createTextNode(text.substring(end)), a.nextSibling);\n                textNode.nodeValue = text.substring(0, start);\n                // remove matched link from interlinks\n                keywords.splice(keywords.indexOf(item), 1);\n              });\n          });\n      }\n    });\n}\n"],"names":["checkAndAddMatch","matches","contender","maxMatches","filter","match","end","start","length","push","interlink","path","language","limit","arguments","undefined","isExceptionLanguage","includes","articleBody","document","querySelector","resp","fetch","concat","ok","json","articleText","textContent","toLowerCase","articleLinks","querySelectorAll","articleWords","split","Math","floor","wordBorder","keywords","Array","isArray","data","_ref","Keyword","indexOf","sort","a","b","map","item","regexp","RegExp","replace","forEach","p","paraLinks","paraWords","maxParaLinks","from","childNodes","node","nodeType","Node","TEXT_NODE","textNode","exec","nodeValue","index","_ref2","text","createElement","title","href","URL","setAttribute","appendChild","createTextNode","substring","insertBefore","nextSibling","splice"],"sourceRoot":""}