{"version":3,"file":"static/js/5289.e8b11412.chunk.js","mappings":"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","sources":["../node_modules/@adobecom/utils/automated-aria.js"],"sourcesContent":["import { getConfig, getFederatedContentRoot } from './utils.js';\n\nconst h1h2Regex = /^h[1-2]$/i;\nconst traverseForTextBeforeHeader = (node, regex) => {\n  if (regex.test(node.tagName)) return { text: '', foundHeader: true };\n  if (node.nodeType === Node.TEXT_NODE) return { text: node.nodeValue, foundHeader: false };\n  let text = '';\n  let foundHeader = false;\n  for (const child of node.childNodes) {\n    const result = traverseForTextBeforeHeader(child, regex);\n    text += result.text;\n    if (result.foundHeader) {\n      foundHeader = true;\n      break;\n    }\n  }\n  return { text, foundHeader };\n};\n\nexport const getTextBeforeHeader = (block) => {\n  if (!block) return '';\n  const { text, foundHeader } = traverseForTextBeforeHeader(block, h1h2Regex);\n  return foundHeader ? text.trim() : '';\n};\n\nexport const getProduct = (text, productNames) => {\n  if (!text) return '';\n  return productNames.find(({ us }) => text.toLowerCase().includes(us.toLowerCase()))?.us || '';\n};\n\nfunction addClassPartToSet(className, parts, extractPrefix) {\n  const segments = className.split('-');\n  if (segments.length > 1) {\n    const partIndex = extractPrefix ? 0 : segments.length - 1;\n    parts.add(segments[partIndex]);\n  }\n}\n\n// Extracts either prefixes or suffixes from a div's class names into a Set\nconst extractClassParts = (div, extractPrefix) => {\n  const classNames = Array.from(div.classList);\n  const parts = new Set();\n  for (const className of classNames) {\n    addClassPartToSet(className, parts, extractPrefix);\n  }\n  return parts;\n};\n\nfunction mapPartToIndices(parts, partToDivIndices, index) {\n  parts.forEach((part) => {\n    if (!partToDivIndices.has(part)) {\n      partToDivIndices.set(part, new Set());\n    }\n    partToDivIndices.get(part).add(index);\n  });\n}\n\n// Helper function to map class parts to the divs that have them\nconst mapPartsToDivIndices = (divs, extractPrefix) => {\n  const partToDivIndices = new Map();\n  divs.forEach((div, index) => {\n    const parts = extractClassParts(div, extractPrefix);\n    mapPartToIndices(parts, partToDivIndices, index);\n  });\n  return partToDivIndices;\n};\n\n// Main function to check for shared class patterns\nconst hasSharedClassPattern = (divs, { extractPrefix = false } = {}) => {\n  if (divs.length < 2) return false; // Need at least 2 divs to share anything\n  const partToDivIndices = mapPartsToDivIndices(divs, extractPrefix);\n  return Array.from(partToDivIndices.values()).some((divIndices) => divIndices.size > 1);\n};\n\nfunction addDeepestContainers(div, findRepeatingContainers, deepestContainers) {\n  const nestedContainers = findRepeatingContainers(div);\n  if (!nestedContainers.length) return;\n\n  let toPush = [];\n  if (nestedContainers.length > 1) {\n    toPush = [...nestedContainers, div];\n  } else if (nestedContainers.length === 1 && nestedContainers[0] === div) {\n    toPush = [div];\n  }\n  deepestContainers.push(...toPush);\n}\n\n// Processes nested divs to find the deepest repeating containers\nconst findDeepestRepeatingContainers = (repeatingDivs, findRepeatingContainers) => {\n  const deepestContainers = [];\n  for (const div of repeatingDivs) {\n    addDeepestContainers(div, findRepeatingContainers, deepestContainers);\n  }\n  return deepestContainers;\n};\n\nconst findRepeatingSiblings = (divs) => divs.filter(\n  (div) => divs.some((otherDiv) => div !== otherDiv && (\n    hasSharedClassPattern([div, otherDiv], { extractPrefix: true })\n      || hasSharedClassPattern([div, otherDiv], { extractPrefix: false })\n  )),\n);\n\n// Finds divs that repeat with a shared class pattern at the same DOM level\n// Containers must be siblings with a shared prefix (e.g., 'card-')\n// or suffix (e.g., '-item') and occur more than once.\nexport const findBlockContainers = (parentContainer) => {\n  const childDivs = Array.from(parentContainer.children).filter((element) => element.tagName === 'DIV');\n  if (!childDivs.length) return [parentContainer];\n\n  const repeatingSiblingDivs = findRepeatingSiblings(childDivs);\n\n  if (repeatingSiblingDivs.length > 1) {\n    const deepestContainers = findDeepestRepeatingContainers(\n      repeatingSiblingDivs,\n      findBlockContainers,\n    );\n    return deepestContainers.length > 1 ? deepestContainers : [parentContainer];\n  }\n\n  const nestedRepeatingContainers = childDivs\n    .map((div) => findBlockContainers(div))\n    .filter((containers) => containers.length > 1);\n\n  return nestedRepeatingContainers.length === 1 && nestedRepeatingContainers[0].length > 1\n    ? nestedRepeatingContainers[0]\n    : [parentContainer];\n};\n\n// Retrieves all h1-h6 headers within container.\nexport const getHeaders = (container) => Array.from(container.querySelectorAll('h1, h2, h3, h4, h5, h6'));\n\n// Helper to get headers outside containers\nconst getHeadersOutsideContainers = (block, containers) => {\n  const allHeaders = getHeaders(block);\n  const containedHeaders = containers.flatMap((c) => getHeaders(c));\n  return allHeaders.filter((h) => !containedHeaders.includes(h));\n};\n\n// Helper to assign ARIA label based on product or header\nconst tryAssignAriaLabel = (\n  cta,\n  headers,\n  productNames,\n  textsToAddProductNames,\n  textsToAddHeaders,\n  textBeforeHeader,\n) => {\n  // Filter out all headers of a level if there are multiple of that level\n  const singleOccurrenceHeaders = headers.filter((header) => {\n    const level = header.tagName.toLowerCase();\n    return headers.filter((h) => h.tagName.toLowerCase() === level).length === 1;\n  });\n\n  const buttonText = cta.textContent.trim().toLowerCase();\n  const productInCTA = (!cta.classList.contains('modal') && getProduct(cta.href?.replace('-', ' '), productNames)) || '';\n  const allContent = [...singleOccurrenceHeaders, textBeforeHeader].filter(Boolean);\n\n  if (textsToAddProductNames.includes(buttonText)) {\n    const productHeader = allContent.find((header) => {\n      const text = typeof header === 'string' ? header : header.textContent.trim();\n      const product = getProduct(text, productNames);\n      return product && (product.includes(productInCTA)\n        || productInCTA.includes(product) || !productInCTA);\n    });\n    if (productHeader) {\n      const productName = getProduct(productHeader.textContent?.trim()\n        || productHeader, productNames);\n      cta.setAttribute('aria-label', `${cta.textContent} ${productName}`);\n      return true;\n    }\n  }\n\n  if (textsToAddHeaders.includes(buttonText) && allContent.length) {\n    const headerText = allContent[0].textContent?.trim() || allContent[0];\n    cta.setAttribute('aria-label', `${cta.textContent} - ${headerText}`);\n    return true;\n  }\n\n  return false;\n};\n\n// Adds an ARIA label to a CTA element based on context (product names or headers).\nexport const addAriaLabelToCTA = (cta, productNames, textsToAddProductNames, textsToAddHeaders) => {\n  const block = cta.closest('.section > div');\n  if (!block) return;\n\n  const containers = findBlockContainers(block);\n  const ctaContainers = containers.filter((container) => container.contains(cta)) || [block];\n  const isInContainer = ctaContainers[0] !== block;\n\n  // Try to assign label from containers first\n  for (const container of ctaContainers) {\n    if (isInContainer && tryAssignAriaLabel(\n      cta,\n      getHeaders(container),\n      productNames,\n      textsToAddProductNames,\n      textsToAddHeaders,\n      getTextBeforeHeader(container),\n    )) return;\n  }\n\n  const uncontainedHeaders = getHeadersOutsideContainers(block, containers);\n  if (uncontainedHeaders.length && tryAssignAriaLabel(\n    cta,\n    uncontainedHeaders,\n    productNames,\n    textsToAddProductNames,\n    textsToAddHeaders,\n  )) {\n    return;\n  }\n  const textBeforeHeader = getTextBeforeHeader(block);\n  tryAssignAriaLabel(\n    cta,\n    getHeaders(block),\n    productNames,\n    textsToAddProductNames,\n    textsToAddHeaders,\n    textBeforeHeader,\n  );\n};\n\n/**\n * Asynchronously adds ARIA labels to all eligible CTAs on the page.\n * Fetches configuration and product names, then applies labels based on locale.\n */\nexport default async function addAriaLabels() {\n  const selector = getConfig().ariaLabelCTASelector || '.con-button:not([aria-label])';\n  const ctas = [...document.body.querySelectorAll(selector)].filter((button) => {\n    const ariaLabel = button.getAttribute('aria-label');\n    return ariaLabel !== '';\n  });\n  if (!ctas.length) return;\n\n  const logError = (msg, error) => window.lana.log(`${msg}: ${error}`, { tags: 'aria' });\n\n  const [configResponse, namesResponse] = await Promise.all([\n    fetch(`${getFederatedContentRoot()}/federal/assets/data/cta-aria-label-config.json`)\n      .catch((e) => logError('Could not fetch cta-aria-label-config.json', e)),\n    fetch(`${getFederatedContentRoot()}/federal/assets/data/product-names.json`)\n      .catch((e) => logError('Could not fetch product-names.json', e)),\n  ]);\n\n  if (!configResponse || !namesResponse) return;\n\n  const ctaAriaLabelConfig = await configResponse.json()\n    .catch((e) => logError('Could not parse cta-aria-label-config.json', e));\n  const productNames = await namesResponse.json()\n    .catch((e) => logError('Could not parse product-names.json', e));\n\n  if (!ctaAriaLabelConfig || !productNames) return;\n\n  const { prefix } = getConfig().locale;\n  const localePrefix = prefix?.replace('/', '') || 'us';\n\n  if (!ctaAriaLabelConfig.data?.length || !productNames.data?.length) {\n    window.lana.log(\n      `No cta aria label config or product names found for locale ${localePrefix}`,\n      { tags: 'aria' },\n    );\n    return;\n  }\n\n  const configForLocale = ctaAriaLabelConfig.data.find((item) => item.prefixes.split(',')\n    .map((p) => p.trim())\n    .includes(localePrefix));\n  if (!configForLocale) return;\n\n  const textsToAddProductNames = configForLocale.addProductName\n    .split(/[\\n,]+/)\n    .map((t) => t.trim().toLowerCase())\n    .filter(Boolean);\n  const textsToAddHeaders = configForLocale.addHeader\n    .split(/[\\n,]+/)\n    .map((t) => t.trim().toLowerCase())\n    .filter(Boolean);\n\n  const modifiedCTAs = [];\n  ctas.forEach((cta) => {\n    addAriaLabelToCTA(cta, productNames.data, textsToAddProductNames, textsToAddHeaders);\n    if (cta.hasAttribute('aria-label')) modifiedCTAs.push(cta);\n  });\n}\n"],"names":["h1h2Regex","traverseForTextBeforeHeader","node","regex","test","tagName","text","foundHeader","nodeType","Node","TEXT_NODE","nodeValue","child","childNodes","result","getTextBeforeHeader","block","trim","getProduct","productNames","_productNames$find","find","_ref","us","toLowerCase","includes","addClassPartToSet","className","parts","extractPrefix","segments","split","length","partIndex","add","mapPartsToDivIndices","divs","partToDivIndices","Map","forEach","div","index","extractClassParts","classNames","Array","from","classList","Set","part","has","set","get","mapPartToIndices","hasSharedClassPattern","arguments","undefined","values","some","divIndices","size","addDeepestContainers","findRepeatingContainers","deepestContainers","nestedContainers","toPush","push","findBlockContainers","parentContainer","childDivs","children","filter","element","repeatingSiblingDivs","otherDiv","findDeepestRepeatingContainers","repeatingDivs","nestedRepeatingContainers","map","containers","getHeaders","container","querySelectorAll","tryAssignAriaLabel","cta","headers","textsToAddProductNames","textsToAddHeaders","textBeforeHeader","_cta$href","singleOccurrenceHeaders","header","level","h","buttonText","textContent","productInCTA","contains","href","replace","allContent","Boolean","productHeader","product","_productHeader$textCo","productName","setAttribute","concat","_allContent$0$textCon","headerText","addAriaLabelToCTA","closest","ctaContainers","isInContainer","uncontainedHeaders","getHeadersOutsideContainers","allHeaders","containedHeaders","flatMap","c","addAriaLabels","_ctaAriaLabelConfig$d","_productNames$data","selector","getConfig","ariaLabelCTASelector","ctas","document","body","button","getAttribute","logError","msg","error","window","lana","log","tags","configResponse","namesResponse","Promise","all","fetch","getFederatedContentRoot","catch","e","ctaAriaLabelConfig","json","prefix","locale","localePrefix","data","configForLocale","item","prefixes","p","addProductName","t","addHeader","modifiedCTAs","hasAttribute"],"sourceRoot":""}