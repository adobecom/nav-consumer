{"version":3,"file":"static/js/8944.0cda0fa7.chunk.js","mappings":"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","sources":["../node_modules/@adobecom/utils/decorate.js","../node_modules/@adobecom/blocks/section-metadata/section-metadata.js"],"sourcesContent":["import {\n  createTag,\n  loadStyle,\n  getConfig,\n  createIntersectionObserver,\n  getFederatedContentRoot,\n  getFedsPlaceholderConfig,\n  shouldBlockFreeTrialLinks,\n} from './utils.js';\n\nconst { miloLibs, codeRoot } = getConfig();\nconst HIDE_CONTROLS = '_hide-controls';\nlet firstVideo = null;\nlet videoLabels = {\n  playMotion: 'Play',\n  pauseMotion: 'Pause',\n  pauseIcon: 'Pause icon',\n  playIcon: 'Play icon',\n  hasFetched: false,\n};\nlet videoCounter = 0;\n\nexport function decorateButtons(el, size) {\n  const buttons = el.querySelectorAll('em a, strong a, p > a strong');\n  if (buttons.length === 0) return;\n  const buttonTypeMap = { STRONG: 'blue', EM: 'outline', A: 'blue' };\n  const localePrefix = getConfig()?.locale?.prefix;\n\n  buttons.forEach((button) => {\n    const parent = button.parentElement;\n    if (shouldBlockFreeTrialLinks({ button, localePrefix, parent })) return;\n    let target = button;\n    const buttonType = buttonTypeMap[parent.nodeName] || 'outline';\n    if (button.nodeName === 'STRONG') {\n      target = parent;\n    } else {\n      parent.insertAdjacentElement('afterend', button);\n      parent.remove();\n    }\n    target.classList.add('con-button', buttonType);\n    if (size) target.classList.add(size); /* button-l, button-xl */\n    const customClasses = target.href && [...target.href.matchAll(/#_button-([a-zA-Z-]+)/g)];\n    if (customClasses) {\n      customClasses.forEach((match) => {\n        target.href = target.href.replace(match[0], '');\n        if (target.dataset.modalHash) {\n          target.setAttribute('data-modal-hash', target.dataset.modalHash.replace(match[0], ''));\n        }\n        target.classList.add(match[1]);\n      });\n    }\n    const actionArea = button.closest('p, div');\n    if (actionArea) {\n      actionArea.classList.add('action-area');\n      actionArea.nextElementSibling?.classList.add('supplemental-text', 'body-xl');\n    }\n  });\n}\n\nexport function decorateIconStack(el) {\n  const ulElems = el.querySelectorAll('ul');\n  if (!ulElems.length) return;\n  const stackEl = ulElems[ulElems.length - 1];\n  stackEl.classList.add('icon-stack-area', 'body-s');\n  el.classList.add('icon-stack');\n  const items = stackEl.querySelectorAll('li');\n  [...items].forEach((i) => {\n    const links = i.querySelectorAll('a');\n    if (links.length <= 1) return;\n    const picIndex = links[0].querySelector('a picture') ? 0 : 1;\n    const linkImg = links[picIndex];\n    const linkText = links[1 - picIndex];\n    const linkPic = linkImg.querySelector('picture');\n    if (linkPic) {\n      linkText.prepend(linkPic);\n      linkImg.remove();\n    }\n  });\n}\n\nexport function decorateIconArea(el) {\n  const icons = el.querySelectorAll('.icon');\n  icons.forEach((icon) => {\n    icon.parentElement.classList.add('icon-area');\n    if (icon.textContent.includes('persona')) icon.parentElement.classList.add('persona-area');\n  });\n}\n\nfunction elContainsText(el) {\n  return [...el.childNodes].some(({ nodeType, innerText, textContent }) => (\n    (nodeType === Node.ELEMENT_NODE && innerText.trim() !== '')\n    || (nodeType === Node.TEXT_NODE && textContent.trim() !== '')\n  ));\n}\n\nexport function decorateBlockText(el, config = ['m', 's', 'm'], type = null) {\n  if (!el.classList.contains('default')) {\n    let headings = el?.querySelectorAll('h1, h2, h3, h4, h5, h6');\n    if (headings) {\n      if (type === 'hasDetailHeading' && headings.length > 1) headings = [...headings].splice(1);\n      headings.forEach((h) => h.classList.add(`heading-${config[0]}`));\n      if (config[2]) {\n        const prevSib = headings[0]?.previousElementSibling;\n        prevSib?.classList.toggle(`detail-${config[2]}`, !prevSib.querySelector('picture'));\n        decorateIconArea(el);\n      }\n    }\n    const bodyStyle = `body-${config[1]}`;\n    const emptyEls = el?.querySelectorAll(':is(p, ul, ol, div):not([class])');\n    if (emptyEls.length) {\n      [...emptyEls].filter(elContainsText).forEach((e) => e.classList.add(bodyStyle));\n    } else if (!el.classList.length && elContainsText(el)) {\n      el.classList.add(bodyStyle);\n    }\n  }\n  const buttonSize = config.length > 3 ? `button-${config[3]}` : '';\n  decorateButtons(el, buttonSize);\n  if (type === 'merch') decorateIconStack(el);\n}\n\nexport function handleFocalpoint(pic, child, removeChild) {\n  const image = pic.querySelector('img');\n  if (!child || !image) return;\n  let text = '';\n  if (child.childElementCount === 2) {\n    const dataElement = child.querySelectorAll('p')[1];\n    text = dataElement?.textContent;\n    if (removeChild) dataElement?.remove();\n  } else if (child.textContent) {\n    text = child.textContent;\n    const childData = child.childNodes;\n    if (removeChild) childData.forEach((c) => c.nodeType === Node.TEXT_NODE && c.remove());\n  }\n  if (!text) return;\n  const directions = text.trim().toLowerCase().split(',');\n  const [x, y = ''] = directions;\n  image.style.objectPosition = `${x} ${y}`;\n}\n\nexport async function decorateBlockBg(block, node, { useHandleFocalpoint = false, className = 'background' } = {}) {\n  const childCount = node.childElementCount;\n  if (node.querySelector('img, video, a[href*=\".mp4\"]') || childCount > 1) {\n    node.classList.add(className);\n    const binaryVP = [['mobile-only'], ['tablet-only', 'desktop-only']];\n    const allVP = [['mobile-only'], ['tablet-only'], ['desktop-only']];\n    const viewports = childCount === 2 ? binaryVP : allVP;\n    [...node.children].forEach((child, i) => {\n      if (childCount > 1 && i < viewports.length) child.classList.add(...viewports[i]);\n      const pic = child.querySelector('picture');\n      if (useHandleFocalpoint && pic\n        && (child.childElementCount === 2 || child.textContent?.trim())) {\n        handleFocalpoint(pic, child, true);\n      }\n      if (!child.querySelector('img, video, a[href*=\".mp4\"]')) {\n        child.style.background = child.textContent;\n        child.classList.add('expand-background');\n        child.textContent = '';\n      }\n    });\n  } else {\n    block.style.background = node.textContent;\n    node.remove();\n  }\n}\n\nexport function getBlockSize(el, defaultSize = 1) {\n  const sizes = ['small', 'medium', 'large', 'xlarge', 'medium-compact'];\n  if (defaultSize < 0 || defaultSize > sizes.length - 1) return null;\n  return sizes.find((size) => el.classList.contains(size)) || sizes[defaultSize];\n}\n\nexport const decorateBlockHrs = (el) => {\n  const pTags = el.querySelectorAll('p');\n  let hasHr = false;\n  const decorateHr = ((tag) => {\n    const hrTag = tag.textContent.trim().startsWith('---');\n    if (!hrTag) return;\n    hasHr = true;\n    const bgStyle = tag.textContent.substring(3).trim();\n    const hrElem = createTag('hr', { style: `background: ${bgStyle};` });\n    tag.textContent = '';\n    tag.appendChild(hrElem);\n  });\n  [...pTags].forEach((p) => {\n    decorateHr(p);\n  });\n  const singleElementInRow = el.children[0].childElementCount === 0;\n  if (singleElementInRow) {\n    decorateHr(el.children[0]);\n  }\n  if (hasHr) el.classList.add('has-divider');\n};\n\nfunction applyTextOverrides(el, override, targetEl) {\n  const parts = override.split('-');\n  const type = parts[1];\n  const scopeEl = (targetEl !== false) ? targetEl : el;\n  const els = scopeEl.querySelectorAll(`[class^=\"${type}\"]`);\n  if (!els.length) return;\n  els.forEach((elem) => {\n    const replace = [...elem.classList].find((i) => i.startsWith(type));\n    elem.classList.replace(replace, `${parts[1]}-${parts[0]}`);\n  });\n}\n\nexport function decorateTextOverrides(el, options = ['-heading', '-body', '-detail'], target = false) {\n  const overrides = [...el.classList]\n    .filter((elClass) => options.findIndex((ovClass) => elClass.endsWith(ovClass)) >= 0);\n  if (!overrides.length) return;\n  overrides.forEach((override) => {\n    applyTextOverrides(el, override, target);\n    el.classList.remove(override);\n  });\n}\n\nfunction defineDeviceByScreenSize() {\n  const screenWidth = window.innerWidth;\n  if (screenWidth <= 600) {\n    return 'mobile';\n  }\n  return 'desktop';\n}\n\nexport function getImgSrc(pic) {\n  let source = '';\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(pic, 'text/html');\n  if (defineDeviceByScreenSize() === 'mobile') source = doc.querySelector('source[type=\"image/webp\"]:not([media])');\n  else source = doc.querySelector('source[type=\"image/webp\"][media]');\n  return source?.srcset ? `poster='${source.srcset}'` : '';\n}\n\nexport function getVideoAttrs(hash, dataset) {\n  const isAutoplay = hash?.includes('autoplay');\n  const isAutoplayOnce = hash?.includes('autoplay1');\n  const playOnHover = hash?.includes('hoverplay');\n  const playInViewport = hash?.includes('viewportplay');\n  const poster = getImgSrc(dataset.videoPoster);\n  const globalAttrs = `playsinline ${poster}`;\n  const autoPlayAttrs = 'autoplay muted';\n  const playInViewportAttrs = playInViewport ? 'data-play-viewport' : '';\n\n  if (isAutoplay && !isAutoplayOnce) {\n    return `${globalAttrs} ${autoPlayAttrs} loop ${playInViewportAttrs}`;\n  }\n  if (playOnHover && isAutoplayOnce) {\n    return `${globalAttrs} ${autoPlayAttrs} data-hoverplay`;\n  }\n  if (playOnHover) {\n    return `${globalAttrs} muted data-hoverplay`;\n  }\n  if (isAutoplayOnce) {\n    return `${globalAttrs} ${autoPlayAttrs} ${playInViewportAttrs}`;\n  }\n  return `${globalAttrs} controls`;\n}\n\nexport function syncPausePlayIcon(video, event) {\n  if (!video.getAttributeNames().includes('data-hoverplay')) {\n    const offsetFiller = video.closest('.video-holder').querySelector('.offset-filler');\n    if (event?.type === 'playing' && offsetFiller?.classList.contains('is-playing')) return;\n    const anchorTag = video.closest('.video-holder').querySelector('a');\n    offsetFiller?.classList.toggle('is-playing');\n    const isPlaying = offsetFiller?.classList.contains('is-playing');\n    const indexOfVideo = (anchorTag.getAttribute('video-index') === '1' && videoCounter === 1) ? '' : anchorTag.getAttribute('video-index');\n    const changedLabel = `${isPlaying ? videoLabels?.pauseMotion : videoLabels?.playMotion}`;\n    const oldLabel = `${!isPlaying ? videoLabels?.pauseMotion : videoLabels?.playMotion}`;\n    const ariaLabel = `${changedLabel} ${indexOfVideo}`.trim();\n    anchorTag?.setAttribute('title', `${ariaLabel}`);\n    anchorTag?.setAttribute('aria-label', `${ariaLabel} `);\n    anchorTag?.setAttribute('aria-pressed', isPlaying ? 'true' : 'false');\n    const daaLL = anchorTag.getAttribute('daa-ll');\n    if (daaLL) anchorTag.setAttribute('daa-ll', daaLL.replace(oldLabel, changedLabel));\n  }\n}\n\nexport function addAccessibilityControl(videoString, videoAttrs, indexOfVideo, tabIndex = 0) {\n  if (videoAttrs.includes('controls')) return videoString;\n  const fedRoot = getFederatedContentRoot();\n  if (videoAttrs.includes('hoverplay')) {\n    return `<a class='pause-play-wrapper video-holder' tabindex=${tabIndex}>${videoString}</a>`;\n  }\n  return `\n    <div class='video-container video-holder'>${videoString}\n      <a class='pause-play-wrapper' title='${videoLabels.pauseMotion}' aria-label='${videoLabels.pauseMotion}' role='button' tabindex=${tabIndex} aria-pressed=true video-index=${indexOfVideo}>\n        <div class='offset-filler'>\n          <img class='accessibility-control pause-icon' alt='${videoLabels.pauseIcon}' src='${fedRoot}/federal/assets/svgs/accessibility-pause.svg'/>\n          <img class='accessibility-control play-icon' alt='${videoLabels.playIcon}' src='${fedRoot}/federal/assets/svgs/accessibility-play.svg'/>\n        </div>\n      </a>\n    </div>\n  `;\n}\n\nfunction isVideoReady(video) {\n  return video.readyState > 1;\n}\n\nexport function handlePause(event) {\n  event.stopPropagation();\n  if (event.code !== 'Enter' && event.code !== 'Space' && !['focus', 'click', 'blur'].includes(event.type)) {\n    return;\n  }\n  event.preventDefault();\n  const video = event.target.closest('.video-holder').parentElement.querySelector('video');\n  if (event.type === 'blur') {\n    video.pause();\n  } else if (video.paused || video.ended || event.type === 'focus') {\n    if (isVideoReady(video)) { video.play(); }\n  } else {\n    video.pause();\n  }\n  syncPausePlayIcon(video);\n}\n\nexport function applyHoverPlay(video) {\n  if (!video) return;\n  if (video.hasAttribute('data-hoverplay')) {\n    video.parentElement.addEventListener('focus', handlePause);\n    video.parentElement.addEventListener('blur', handlePause);\n    if (!video.hasAttribute('data-mouseevent')) {\n      video.addEventListener('mouseenter', () => { if (isVideoReady(video)) { video.play(); } });\n      video.addEventListener('mouseleave', () => { if (isVideoReady(video)) { video.pause(); } });\n      video.addEventListener('ended', () => { syncPausePlayIcon(video); });\n      video.setAttribute('data-mouseevent', true);\n    }\n  }\n}\n\nexport function applyAccessibilityEvents(videoEl) {\n  const pausePlayWrapper = videoEl.parentElement.querySelector('.pause-play-wrapper') || videoEl.closest('.pause-play-wrapper');\n  if (pausePlayWrapper?.querySelector('.accessibility-control')) {\n    pausePlayWrapper.addEventListener('click', handlePause);\n    pausePlayWrapper.addEventListener('keydown', handlePause);\n  }\n  if (videoEl.hasAttribute('autoplay')) {\n    videoEl.addEventListener('canplay', () => videoEl.play());\n    videoEl.addEventListener('playing', (event) => syncPausePlayIcon(videoEl, event));\n    videoEl.addEventListener('ended', () => syncPausePlayIcon(videoEl));\n  }\n}\n\nfunction setObjectFitAndPos(text, pic, bgEl, objFitOptions) {\n  const backgroundConfig = text.split(',').map((c) => c.toLowerCase().trim());\n  const fitOption = objFitOptions.filter((c) => backgroundConfig.includes(c));\n  const focusOption = backgroundConfig.filter((c) => !fitOption.includes(c));\n  if (fitOption) [pic.querySelector('img').style.objectFit] = fitOption;\n  bgEl.innerHTML = '';\n  bgEl.append(pic);\n  bgEl.append(document.createTextNode(focusOption.join(',')));\n}\n\nexport function handleObjectFit(bgRow) {\n  const bgConfig = bgRow.querySelectorAll('div');\n  [...bgConfig].forEach((r) => {\n    const pic = r.querySelector('picture');\n    if (!pic) return;\n    let text = '';\n    const pchild = [...r.querySelectorAll('p:not(:empty)')].filter((p) => p.innerHTML.trim() !== '');\n    if (pchild.length > 2) text = pchild[1]?.textContent.trim();\n    if (!text && r.textContent) text = r.textContent;\n    if (!text) return;\n    setObjectFitAndPos(text, pic, r, ['fill', 'contain', 'cover', 'none', 'scale-down']);\n  });\n}\n\nfunction getVideoIntersectionObserver() {\n  if (!window?.videoIntersectionObs) {\n    window.videoIntersectionObs = new window.IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        const { intersectionRatio, target: video } = entry;\n        const isHaveLoopAttr = video.getAttributeNames().includes('loop');\n        const { playedOnce = false } = video.dataset;\n        const isPlaying = video.currentTime > 0 && !video.paused && !video.ended\n          && video.readyState > video.HAVE_CURRENT_DATA;\n\n        if (intersectionRatio <= 0.8) {\n          video.pause();\n        } else if ((isHaveLoopAttr || !playedOnce) && !isPlaying) {\n          video.play();\n        }\n      });\n    }, { threshold: [0.8] });\n  }\n  return window.videoIntersectionObs;\n}\n\nfunction applyInViewPortPlay(video) {\n  if (!video) return;\n  if (video.hasAttribute('data-play-viewport')) {\n    const observer = getVideoIntersectionObserver();\n    video.addEventListener('ended', () => {\n      video.dataset.playedOnce = true;\n    });\n    observer.observe(video);\n  }\n}\n\nexport function decorateMultiViewport(el) {\n  const foreground = el.querySelector('.foreground');\n  const cols = foreground.childElementCount;\n  if (cols === 2 || cols === 3) {\n    const viewports = [\n      '(max-width: 599px)',\n      '(min-width: 600px) and (max-width: 1199px)',\n      '(min-width: 1200px)',\n      '(min-width: 600px)',\n    ].filter((v, i) => (cols === 2 ? [0, 3].includes(i) : i !== 3));\n    [...foreground.children].forEach((child, index) => {\n      const mq = window.matchMedia(viewports[index]);\n      const setContent = () => mq.matches && foreground.replaceChildren(child);\n      setContent();\n      mq.addEventListener('change', setContent);\n    });\n  }\n  return foreground;\n}\n\nexport async function loadCDT(el, classList) {\n  try {\n    await Promise.all([\n      loadStyle(`${miloLibs || codeRoot}/features/cdt/cdt.css`),\n      import('../features/cdt/cdt.js')\n        .then(({ default: initCDT }) => initCDT(el, classList)),\n    ]);\n  } catch (error) {\n    window.lana?.log(`WARN: Failed to load countdown timer: ${error}`, { tags: 'errorType=warn,module=countdown-timer' });\n  }\n}\n\nexport function isVideoAccessible(anchorTag) {\n  return !anchorTag?.hash.includes(HIDE_CONTROLS);\n}\n\nfunction updateFirstVideo() {\n  if (firstVideo != null && firstVideo?.controls === false && videoCounter > 1) {\n    let videoHolder = document.querySelector('[video-index=\"1\"]') || firstVideo.closest('.video-holder');\n    if (videoHolder.nodeName !== 'A') videoHolder = videoHolder.querySelector('a.pause-play-wrapper');\n    const firstVideoLabel = videoHolder.getAttribute('aria-label');\n    videoHolder.setAttribute('aria-label', `${firstVideoLabel} 1`);\n    firstVideo = null;\n  }\n}\n\nfunction updateAriaLabel(videoEl, videoAttrs) {\n  if (!videoEl.getAttributeNames().includes('data-hoverplay')) {\n    const pausePlayWrapper = videoEl.parentElement.querySelector('.pause-play-wrapper') || videoEl.closest('.pause-play-wrapper');\n    const pauseIcon = pausePlayWrapper.querySelector('.pause-icon');\n    const playIcon = pausePlayWrapper.querySelector('.play-icon');\n    const indexOfVideo = pausePlayWrapper.getAttribute('video-index');\n    let ariaLabel = `${videoAttrs.includes('autoplay') ? videoLabels.pauseMotion : videoLabels.playMotion}`;\n    ariaLabel = ariaLabel.concat(` ${indexOfVideo === '1' && videoCounter === 1 ? '' : indexOfVideo}`);\n    pausePlayWrapper.setAttribute('aria-label', ariaLabel);\n    pauseIcon.setAttribute('alt', videoLabels.pauseMotion);\n    playIcon.setAttribute('alt', videoLabels.playMotion);\n    updateFirstVideo();\n  }\n}\n\nexport function decoratePausePlayWrapper(videoEl, videoAttrs) {\n  if (!videoLabels.hasFetched) {\n    import('../features/placeholders.js').then(({ replaceKeyArray }) => {\n      replaceKeyArray(['pause-motion', 'play-motion', 'pause-icon', 'play-icon'], getFedsPlaceholderConfig())\n        .then(([pauseMotion, playMotion, pauseIcon, playIcon]) => {\n          videoLabels = { playMotion, pauseMotion, pauseIcon, playIcon };\n          videoLabels.hasFetched = true;\n          updateAriaLabel(videoEl, videoAttrs);\n        });\n    });\n  } else {\n    updateAriaLabel(videoEl, videoAttrs);\n  }\n}\n\nexport function decorateAnchorVideo({ src = '', anchorTag }) {\n  if (!src.length || !(anchorTag instanceof HTMLElement)) return;\n  const accessibilityEnabled = isVideoAccessible(anchorTag);\n  anchorTag.hash = anchorTag.hash.replace(`#${HIDE_CONTROLS}`, '');\n  if (anchorTag.closest('.marquee, .aside, .hero-marquee, .quiz-marquee') && !anchorTag.hash) anchorTag.hash = '#autoplay';\n  const { dataset, parentElement } = anchorTag;\n  const attrs = getVideoAttrs(anchorTag.hash, dataset);\n  const tabIndex = anchorTag.tabIndex || 0;\n  const videoIndex = (tabIndex === -1) ? 'tabindex=-1' : '';\n  let video = `<video ${attrs} data-video-source=${src} ${videoIndex}></video>`;\n  if (!attrs.includes('controls') && !attrs.includes('hoverplay') && accessibilityEnabled) {\n    videoCounter += 1;\n  }\n  const indexOfVideo = videoCounter;\n  if (accessibilityEnabled) {\n    video = addAccessibilityControl(video, attrs, indexOfVideo, tabIndex);\n  }\n  anchorTag.insertAdjacentHTML('afterend', video);\n  const videoEl = parentElement.querySelector('video');\n  if (indexOfVideo === 1) {\n    firstVideo = videoEl;\n  }\n\n  createIntersectionObserver({\n    el: videoEl,\n    options: { rootMargin: '1000px' },\n    callback: () => {\n      if (videoEl.querySelector('source')) return;\n      videoEl.appendChild(createTag('source', { src, type: 'video/mp4' }));\n    },\n  });\n\n  if (videoEl.controls) {\n    const io = new IntersectionObserver((entries) => {\n      entries.forEach(({ isIntersecting, target }) => {\n        if (!isIntersecting && !target.paused) target.pause();\n      });\n    }, { rootMargin: '0px' });\n    io.observe(videoEl);\n  }\n\n  if (accessibilityEnabled) {\n    applyAccessibilityEvents(videoEl);\n    if (!videoEl.controls) {\n      decoratePausePlayWrapper(videoEl, attrs);\n    }\n  }\n  applyHoverPlay(videoEl);\n  applyInViewPortPlay(videoEl);\n  anchorTag.remove();\n}\n","import { handleFocalpoint } from '../../utils/decorate.js';\n\nexport function handleBackground(div, section) {\n  const pic = div.background.content?.querySelector('picture');\n  if (pic) {\n    section.classList.add('has-background');\n    pic.classList.add('section-background');\n    handleFocalpoint(pic, div.background.content);\n    section.insertAdjacentElement('afterbegin', pic);\n  } else {\n    const color = div.background.content?.textContent;\n    if (color) {\n      section.style.background = color;\n    }\n  }\n}\n\nexport async function handleStyle(text, section) {\n  if (!text || !section) return;\n  const styles = text.split(', ').map((style) => style.replaceAll(' ', '-'));\n  const sticky = styles.find((style) => style === 'sticky-top' || style === 'sticky-bottom');\n  if (sticky) {\n    const { default: handleStickySection } = await import('./sticky-section.js');\n    await handleStickySection(sticky, section);\n  }\n  if (styles.includes('masonry')) styles.push('masonry-up');\n  section.classList.add(...styles);\n}\n\nfunction handleMasonry(text, section) {\n  section.classList.add(...['masonry-layout', 'masonry-up']);\n  const divs = section.querySelectorAll(\":scope > div:not([class*='metadata'])\");\n  const spans = [];\n  text.split('\\n').forEach((line) => spans.push(...line.trim().split(',')));\n  [...divs].forEach((div, i) => {\n    const spanWidth = spans[i] ? spans[i] : 'span 4';\n    div.classList.add(`grid-${spanWidth.trim().replace(' ', '-')}`);\n  });\n}\n\nfunction handleLayout(text, section) {\n  if (!(text || section)) return;\n  const layoutClass = `grid-template-columns-${text.replaceAll(' | ', '-')}`;\n  section.classList.add(layoutClass);\n}\n\nexport function getDelayTime(time) {\n  if (time > 99) return time;\n  return (time * 1000);\n}\n\nfunction handleDelay(time, section) {\n  if (!(time || section)) return;\n  section.classList.add('hide-sticky-section');\n  setTimeout(() => { section.classList.remove('hide-sticky-section'); }, getDelayTime(time));\n}\n\nfunction handleAnchor(anchor, section) {\n  if (!anchor || !section) return;\n  section.id = anchor.toLowerCase().trim().replaceAll(/\\s+/g, '-');\n  section.classList.add('section-anchor');\n}\n\nexport const getMetadata = (el) => [...el.childNodes].reduce((rdx, row) => {\n  if (row.children) {\n    const key = row.children[0].textContent.trim().toLowerCase();\n    const content = row.children[1];\n    const text = content.textContent.trim().toLowerCase();\n    if (key && content) rdx[key] = { content, text };\n  }\n  return rdx;\n}, {});\n\nexport default async function init(el) {\n  const section = el.closest('.section');\n  const metadata = getMetadata(el);\n  if (metadata.style) await handleStyle(metadata.style.text, section);\n  if (metadata.background) handleBackground(metadata, section);\n  if (metadata.layout) handleLayout(metadata.layout.text, section);\n  if (metadata.masonry) handleMasonry(metadata.masonry.text, section);\n  if (metadata.delay) handleDelay(metadata.delay.text, section);\n  if (metadata.anchor) handleAnchor(metadata.anchor.text, section);\n}\n"],"names":["miloLibs","q","codeRoot","k","c","p","n","e","_n$background$content","t","background","content","querySelector","classList","add","s","o","childElementCount","r","querySelectorAll","textContent","remove","childNodes","forEach","l","nodeType","Node","TEXT_NODE","a","trim","toLowerCase","split","i","u","style","objectPosition","concat","d","insertAdjacentElement","_n$background$content2","f","map","replaceAll","find","default","includes","push","h","x","reduce","children","text","L","closest","layout","m","masonry","replace","y","delay","setTimeout","b","anchor","id","g"],"sourceRoot":""}