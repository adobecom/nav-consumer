{"version":3,"file":"static/js/8905.dfc23e98.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js","../node_modules/@adobecom/utils/decorate.js","../node_modules/@adobecom/blocks/section-metadata/section-metadata.js","../node_modules/@adobecom/blocks/section-metadata/sticky-section.js"],"sourcesContent":["function _taggedTemplateLiteral(e, t) {\n  return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {\n    raw: {\n      value: Object.freeze(t)\n    }\n  }));\n}\nexport { _taggedTemplateLiteral as default };","import {\n  createTag,\n  loadStyle,\n  getConfig,\n  createIntersectionObserver,\n  getFederatedContentRoot,\n  getFedsPlaceholderConfig,\n  shouldBlockFreeTrialLinks,\n} from './utils.js';\n\nconst { miloLibs, codeRoot } = getConfig();\nconst HIDE_CONTROLS = '_hide-controls';\nlet firstVideo = null;\nlet videoLabels = {\n  playMotion: 'Play',\n  pauseMotion: 'Pause',\n  pauseIcon: 'Pause icon',\n  playIcon: 'Play icon',\n  hasFetched: false,\n};\nlet videoCounter = 0;\n\nexport function decorateButtons(el, size) {\n  const buttons = el.querySelectorAll('em a, strong a, p > a strong');\n  if (buttons.length === 0) return;\n  const buttonTypeMap = { STRONG: 'blue', EM: 'outline', A: 'blue' };\n  const localePrefix = getConfig()?.locale?.prefix;\n\n  buttons.forEach((button) => {\n    const parent = button.parentElement;\n    if (shouldBlockFreeTrialLinks({ button, localePrefix, parent })) return;\n    let target = button;\n    const buttonType = buttonTypeMap[parent.nodeName] || 'outline';\n    if (button.nodeName === 'STRONG') {\n      target = parent;\n    } else {\n      parent.insertAdjacentElement('afterend', button);\n      parent.remove();\n    }\n    target.classList.add('con-button', buttonType);\n    if (size) target.classList.add(size); /* button-l, button-xl */\n    const customClasses = target.href && [...target.href.matchAll(/#_button-([a-zA-Z-]+)/g)];\n    if (customClasses) {\n      customClasses.forEach((match) => {\n        target.href = target.href.replace(match[0], '');\n        if (target.dataset.modalHash) {\n          target.setAttribute('data-modal-hash', target.dataset.modalHash.replace(match[0], ''));\n        }\n        target.classList.add(match[1]);\n      });\n    }\n    const actionArea = button.closest('p, div');\n    if (actionArea) {\n      actionArea.classList.add('action-area');\n      actionArea.nextElementSibling?.classList.add('supplemental-text', 'body-xl');\n    }\n  });\n}\n\nexport function decorateIconStack(el) {\n  const ulElems = el.querySelectorAll('ul');\n  if (!ulElems.length) return;\n  const stackEl = ulElems[ulElems.length - 1];\n  stackEl.classList.add('icon-stack-area', 'body-s');\n  el.classList.add('icon-stack');\n  const items = stackEl.querySelectorAll('li');\n  [...items].forEach((i) => {\n    const links = i.querySelectorAll('a');\n    if (links.length <= 1) return;\n    const picIndex = links[0].querySelector('a picture') ? 0 : 1;\n    const linkImg = links[picIndex];\n    const linkText = links[1 - picIndex];\n    const linkPic = linkImg.querySelector('picture');\n    if (linkPic) {\n      linkText.prepend(linkPic);\n      linkImg.remove();\n    }\n  });\n}\n\nexport function decorateIconArea(el) {\n  const icons = el.querySelectorAll('.icon');\n  icons.forEach((icon) => {\n    icon.parentElement.classList.add('icon-area');\n    if (icon.textContent.includes('persona')) icon.parentElement.classList.add('persona-area');\n  });\n}\n\nfunction elContainsText(el) {\n  return [...el.childNodes].some(({ nodeType, innerText, textContent }) => (\n    (nodeType === Node.ELEMENT_NODE && innerText.trim() !== '')\n    || (nodeType === Node.TEXT_NODE && textContent.trim() !== '')\n  ));\n}\n\nexport function decorateBlockText(el, config = ['m', 's', 'm'], type = null) {\n  if (!el.classList.contains('default')) {\n    let headings = el?.querySelectorAll('h1, h2, h3, h4, h5, h6');\n    if (headings) {\n      if (type === 'hasDetailHeading' && headings.length > 1) headings = [...headings].splice(1);\n      headings.forEach((h) => h.classList.add(`heading-${config[0]}`));\n      if (config[2]) {\n        const prevSib = headings[0]?.previousElementSibling;\n        prevSib?.classList.toggle(`detail-${config[2]}`, !prevSib.querySelector('picture'));\n        decorateIconArea(el);\n      }\n    }\n    const bodyStyle = `body-${config[1]}`;\n    const emptyEls = el?.querySelectorAll(':is(p, ul, ol, div):not([class])');\n    if (emptyEls.length) {\n      [...emptyEls].filter(elContainsText).forEach((e) => e.classList.add(bodyStyle));\n    } else if (!el.classList.length && elContainsText(el)) {\n      el.classList.add(bodyStyle);\n    }\n  }\n  const buttonSize = config.length > 3 ? `button-${config[3]}` : '';\n  decorateButtons(el, buttonSize);\n  if (type === 'merch') decorateIconStack(el);\n}\n\nexport function handleFocalpoint(pic, child, removeChild) {\n  const image = pic.querySelector('img');\n  if (!child || !image) return;\n  let text = '';\n  if (child.childElementCount === 2) {\n    const dataElement = child.querySelectorAll('p')[1];\n    text = dataElement?.textContent;\n    if (removeChild) dataElement?.remove();\n  } else if (child.textContent) {\n    text = child.textContent;\n    const childData = child.childNodes;\n    if (removeChild) childData.forEach((c) => c.nodeType === Node.TEXT_NODE && c.remove());\n  }\n  if (!text) return;\n  const directions = text.trim().toLowerCase().split(',');\n  const [x, y = ''] = directions;\n  image.style.objectPosition = `${x} ${y}`;\n}\n\nexport async function decorateBlockBg(block, node, { useHandleFocalpoint = false, className = 'background' } = {}) {\n  const childCount = node.childElementCount;\n  if (node.querySelector('img, video, a[href*=\".mp4\"]') || childCount > 1) {\n    node.classList.add(className);\n    const binaryVP = [['mobile-only'], ['tablet-only', 'desktop-only']];\n    const allVP = [['mobile-only'], ['tablet-only'], ['desktop-only']];\n    const viewports = childCount === 2 ? binaryVP : allVP;\n    [...node.children].forEach((child, i) => {\n      if (childCount > 1 && i < viewports.length) child.classList.add(...viewports[i]);\n      const pic = child.querySelector('picture');\n      if (useHandleFocalpoint && pic\n        && (child.childElementCount === 2 || child.textContent?.trim())) {\n        handleFocalpoint(pic, child, true);\n      }\n      if (!child.querySelector('img, video, a[href*=\".mp4\"]')) {\n        child.style.background = child.textContent;\n        child.classList.add('expand-background');\n        child.textContent = '';\n      }\n    });\n  } else {\n    block.style.background = node.textContent;\n    node.remove();\n  }\n}\n\nexport function getBlockSize(el, defaultSize = 1) {\n  const sizes = ['small', 'medium', 'large', 'xlarge', 'medium-compact'];\n  if (defaultSize < 0 || defaultSize > sizes.length - 1) return null;\n  return sizes.find((size) => el.classList.contains(size)) || sizes[defaultSize];\n}\n\nexport const decorateBlockHrs = (el) => {\n  const pTags = el.querySelectorAll('p');\n  let hasHr = false;\n  const decorateHr = ((tag) => {\n    const hrTag = tag.textContent.trim().startsWith('---');\n    if (!hrTag) return;\n    hasHr = true;\n    const bgStyle = tag.textContent.substring(3).trim();\n    const hrElem = createTag('hr', { style: `background: ${bgStyle};` });\n    tag.textContent = '';\n    tag.appendChild(hrElem);\n  });\n  [...pTags].forEach((p) => {\n    decorateHr(p);\n  });\n  const singleElementInRow = el.children[0].childElementCount === 0;\n  if (singleElementInRow) {\n    decorateHr(el.children[0]);\n  }\n  if (hasHr) el.classList.add('has-divider');\n};\n\nfunction applyTextOverrides(el, override, targetEl) {\n  const parts = override.split('-');\n  const type = parts[1];\n  const scopeEl = (targetEl !== false) ? targetEl : el;\n  const els = scopeEl.querySelectorAll(`[class^=\"${type}\"]`);\n  if (!els.length) return;\n  els.forEach((elem) => {\n    const replace = [...elem.classList].find((i) => i.startsWith(type));\n    elem.classList.replace(replace, `${parts[1]}-${parts[0]}`);\n  });\n}\n\nexport function decorateTextOverrides(el, options = ['-heading', '-body', '-detail'], target = false) {\n  const overrides = [...el.classList]\n    .filter((elClass) => options.findIndex((ovClass) => elClass.endsWith(ovClass)) >= 0);\n  if (!overrides.length) return;\n  overrides.forEach((override) => {\n    applyTextOverrides(el, override, target);\n    el.classList.remove(override);\n  });\n}\n\nfunction defineDeviceByScreenSize() {\n  const screenWidth = window.innerWidth;\n  if (screenWidth <= 600) {\n    return 'mobile';\n  }\n  return 'desktop';\n}\n\nexport function getImgSrc(pic) {\n  let source = '';\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(pic, 'text/html');\n  if (defineDeviceByScreenSize() === 'mobile') source = doc.querySelector('source[type=\"image/webp\"]:not([media])');\n  else source = doc.querySelector('source[type=\"image/webp\"][media]');\n  return source?.srcset ? `poster='${source.srcset}'` : '';\n}\n\nexport function getVideoAttrs(hash, dataset) {\n  const isAutoplay = hash?.includes('autoplay');\n  const isAutoplayOnce = hash?.includes('autoplay1');\n  const playOnHover = hash?.includes('hoverplay');\n  const playInViewport = hash?.includes('viewportplay');\n  const poster = getImgSrc(dataset.videoPoster);\n  const globalAttrs = `playsinline ${poster}`;\n  const autoPlayAttrs = 'autoplay muted';\n  const playInViewportAttrs = playInViewport ? 'data-play-viewport' : '';\n\n  if (isAutoplay && !isAutoplayOnce) {\n    return `${globalAttrs} ${autoPlayAttrs} loop ${playInViewportAttrs}`;\n  }\n  if (playOnHover && isAutoplayOnce) {\n    return `${globalAttrs} ${autoPlayAttrs} data-hoverplay`;\n  }\n  if (playOnHover) {\n    return `${globalAttrs} muted data-hoverplay`;\n  }\n  if (isAutoplayOnce) {\n    return `${globalAttrs} ${autoPlayAttrs} ${playInViewportAttrs}`;\n  }\n  return `${globalAttrs} controls`;\n}\n\nexport function syncPausePlayIcon(video, event) {\n  if (!video.getAttributeNames().includes('data-hoverplay')) {\n    const offsetFiller = video.closest('.video-holder').querySelector('.offset-filler');\n    if (event?.type === 'playing' && offsetFiller?.classList.contains('is-playing')) return;\n    const anchorTag = video.closest('.video-holder').querySelector('a');\n    offsetFiller?.classList.toggle('is-playing');\n    const isPlaying = offsetFiller?.classList.contains('is-playing');\n    const indexOfVideo = (anchorTag.getAttribute('video-index') === '1' && videoCounter === 1) ? '' : anchorTag.getAttribute('video-index');\n    const changedLabel = `${isPlaying ? videoLabels?.pauseMotion : videoLabels?.playMotion}`;\n    const oldLabel = `${!isPlaying ? videoLabels?.pauseMotion : videoLabels?.playMotion}`;\n    const ariaLabel = `${changedLabel} ${indexOfVideo}`.trim();\n    anchorTag?.setAttribute('title', `${ariaLabel}`);\n    anchorTag?.setAttribute('aria-label', `${ariaLabel} `);\n    anchorTag?.setAttribute('aria-pressed', isPlaying ? 'true' : 'false');\n    const daaLL = anchorTag.getAttribute('daa-ll');\n    if (daaLL) anchorTag.setAttribute('daa-ll', daaLL.replace(oldLabel, changedLabel));\n  }\n}\n\nexport function addAccessibilityControl(videoString, videoAttrs, indexOfVideo, tabIndex = 0) {\n  if (videoAttrs.includes('controls')) return videoString;\n  const fedRoot = getFederatedContentRoot();\n  if (videoAttrs.includes('hoverplay')) {\n    return `<a class='pause-play-wrapper video-holder' tabindex=${tabIndex}>${videoString}</a>`;\n  }\n  return `\n    <div class='video-container video-holder'>${videoString}\n      <a class='pause-play-wrapper' title='${videoLabels.pauseMotion}' aria-label='${videoLabels.pauseMotion}' role='button' tabindex=${tabIndex} aria-pressed=true video-index=${indexOfVideo}>\n        <div class='offset-filler'>\n          <img class='accessibility-control pause-icon' alt='${videoLabels.pauseIcon}' src='${fedRoot}/federal/assets/svgs/accessibility-pause.svg'/>\n          <img class='accessibility-control play-icon' alt='${videoLabels.playIcon}' src='${fedRoot}/federal/assets/svgs/accessibility-play.svg'/>\n        </div>\n      </a>\n    </div>\n  `;\n}\n\nfunction isVideoReady(video) {\n  return video.readyState > 1;\n}\n\nexport function handlePause(event) {\n  event.stopPropagation();\n  if (event.code !== 'Enter' && event.code !== 'Space' && !['focus', 'click', 'blur'].includes(event.type)) {\n    return;\n  }\n  event.preventDefault();\n  const video = event.target.closest('.video-holder').parentElement.querySelector('video');\n  if (event.type === 'blur') {\n    video.pause();\n  } else if (video.paused || video.ended || event.type === 'focus') {\n    if (isVideoReady(video)) { video.play(); }\n  } else {\n    video.pause();\n  }\n  syncPausePlayIcon(video);\n}\n\nexport function applyHoverPlay(video) {\n  if (!video) return;\n  if (video.hasAttribute('data-hoverplay')) {\n    video.parentElement.addEventListener('focus', handlePause);\n    video.parentElement.addEventListener('blur', handlePause);\n    if (!video.hasAttribute('data-mouseevent')) {\n      video.addEventListener('mouseenter', () => { if (isVideoReady(video)) { video.play(); } });\n      video.addEventListener('mouseleave', () => { if (isVideoReady(video)) { video.pause(); } });\n      video.addEventListener('ended', () => { syncPausePlayIcon(video); });\n      video.setAttribute('data-mouseevent', true);\n    }\n  }\n}\n\nexport function applyAccessibilityEvents(videoEl) {\n  const pausePlayWrapper = videoEl.parentElement.querySelector('.pause-play-wrapper') || videoEl.closest('.pause-play-wrapper');\n  if (pausePlayWrapper?.querySelector('.accessibility-control')) {\n    pausePlayWrapper.addEventListener('click', handlePause);\n    pausePlayWrapper.addEventListener('keydown', handlePause);\n  }\n  if (videoEl.hasAttribute('autoplay')) {\n    videoEl.addEventListener('canplay', () => videoEl.play());\n    videoEl.addEventListener('playing', (event) => syncPausePlayIcon(videoEl, event));\n    videoEl.addEventListener('ended', () => syncPausePlayIcon(videoEl));\n  }\n}\n\nfunction setObjectFitAndPos(text, pic, bgEl, objFitOptions) {\n  const backgroundConfig = text.split(',').map((c) => c.toLowerCase().trim());\n  const fitOption = objFitOptions.filter((c) => backgroundConfig.includes(c));\n  const focusOption = backgroundConfig.filter((c) => !fitOption.includes(c));\n  if (fitOption) [pic.querySelector('img').style.objectFit] = fitOption;\n  bgEl.innerHTML = '';\n  bgEl.append(pic);\n  bgEl.append(document.createTextNode(focusOption.join(',')));\n}\n\nexport function handleObjectFit(bgRow) {\n  const bgConfig = bgRow.querySelectorAll('div');\n  [...bgConfig].forEach((r) => {\n    const pic = r.querySelector('picture');\n    if (!pic) return;\n    let text = '';\n    const pchild = [...r.querySelectorAll('p:not(:empty)')].filter((p) => p.innerHTML.trim() !== '');\n    if (pchild.length > 2) text = pchild[1]?.textContent.trim();\n    if (!text && r.textContent) text = r.textContent;\n    if (!text) return;\n    setObjectFitAndPos(text, pic, r, ['fill', 'contain', 'cover', 'none', 'scale-down']);\n  });\n}\n\nfunction getVideoIntersectionObserver() {\n  if (!window?.videoIntersectionObs) {\n    window.videoIntersectionObs = new window.IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        const { intersectionRatio, target: video } = entry;\n        const isHaveLoopAttr = video.getAttributeNames().includes('loop');\n        const { playedOnce = false } = video.dataset;\n        const isPlaying = video.currentTime > 0 && !video.paused && !video.ended\n          && video.readyState > video.HAVE_CURRENT_DATA;\n\n        if (intersectionRatio <= 0.8) {\n          video.pause();\n        } else if ((isHaveLoopAttr || !playedOnce) && !isPlaying) {\n          video.play();\n        }\n      });\n    }, { threshold: [0.8] });\n  }\n  return window.videoIntersectionObs;\n}\n\nfunction applyInViewPortPlay(video) {\n  if (!video) return;\n  if (video.hasAttribute('data-play-viewport')) {\n    const observer = getVideoIntersectionObserver();\n    video.addEventListener('ended', () => {\n      video.dataset.playedOnce = true;\n    });\n    observer.observe(video);\n  }\n}\n\nexport function decorateMultiViewport(el) {\n  const foreground = el.querySelector('.foreground');\n  const cols = foreground.childElementCount;\n  if (cols === 2 || cols === 3) {\n    const viewports = [\n      '(max-width: 599px)',\n      '(min-width: 600px) and (max-width: 1199px)',\n      '(min-width: 1200px)',\n      '(min-width: 600px)',\n    ].filter((v, i) => (cols === 2 ? [0, 3].includes(i) : i !== 3));\n    [...foreground.children].forEach((child, index) => {\n      const mq = window.matchMedia(viewports[index]);\n      const setContent = () => mq.matches && foreground.replaceChildren(child);\n      setContent();\n      mq.addEventListener('change', setContent);\n    });\n  }\n  return foreground;\n}\n\nexport async function loadCDT(el, classList) {\n  try {\n    await Promise.all([\n      loadStyle(`${miloLibs || codeRoot}/features/cdt/cdt.css`),\n      import('../features/cdt/cdt.js')\n        .then(({ default: initCDT }) => initCDT(el, classList)),\n    ]);\n  } catch (error) {\n    window.lana?.log(`WARN: Failed to load countdown timer: ${error}`, { tags: 'errorType=warn,module=countdown-timer' });\n  }\n}\n\nexport function isVideoAccessible(anchorTag) {\n  return !anchorTag?.hash.includes(HIDE_CONTROLS);\n}\n\nfunction updateFirstVideo() {\n  if (firstVideo != null && firstVideo?.controls === false && videoCounter > 1) {\n    let videoHolder = document.querySelector('[video-index=\"1\"]') || firstVideo.closest('.video-holder');\n    if (videoHolder.nodeName !== 'A') videoHolder = videoHolder.querySelector('a.pause-play-wrapper');\n    const firstVideoLabel = videoHolder.getAttribute('aria-label');\n    videoHolder.setAttribute('aria-label', `${firstVideoLabel} 1`);\n    firstVideo = null;\n  }\n}\n\nfunction updateAriaLabel(videoEl, videoAttrs) {\n  if (!videoEl.getAttributeNames().includes('data-hoverplay')) {\n    const pausePlayWrapper = videoEl.parentElement.querySelector('.pause-play-wrapper') || videoEl.closest('.pause-play-wrapper');\n    const pauseIcon = pausePlayWrapper.querySelector('.pause-icon');\n    const playIcon = pausePlayWrapper.querySelector('.play-icon');\n    const indexOfVideo = pausePlayWrapper.getAttribute('video-index');\n    let ariaLabel = `${videoAttrs.includes('autoplay') ? videoLabels.pauseMotion : videoLabels.playMotion}`;\n    ariaLabel = ariaLabel.concat(` ${indexOfVideo === '1' && videoCounter === 1 ? '' : indexOfVideo}`);\n    pausePlayWrapper.setAttribute('aria-label', ariaLabel);\n    pauseIcon.setAttribute('alt', videoLabels.pauseMotion);\n    playIcon.setAttribute('alt', videoLabels.playMotion);\n    updateFirstVideo();\n  }\n}\n\nexport function decoratePausePlayWrapper(videoEl, videoAttrs) {\n  if (!videoLabels.hasFetched) {\n    import('../features/placeholders.js').then(({ replaceKeyArray }) => {\n      replaceKeyArray(['pause-motion', 'play-motion', 'pause-icon', 'play-icon'], getFedsPlaceholderConfig())\n        .then(([pauseMotion, playMotion, pauseIcon, playIcon]) => {\n          videoLabels = { playMotion, pauseMotion, pauseIcon, playIcon };\n          videoLabels.hasFetched = true;\n          updateAriaLabel(videoEl, videoAttrs);\n        });\n    });\n  } else {\n    updateAriaLabel(videoEl, videoAttrs);\n  }\n}\n\nexport function decorateAnchorVideo({ src = '', anchorTag }) {\n  if (!src.length || !(anchorTag instanceof HTMLElement)) return;\n  const accessibilityEnabled = isVideoAccessible(anchorTag);\n  anchorTag.hash = anchorTag.hash.replace(`#${HIDE_CONTROLS}`, '');\n  if (anchorTag.closest('.marquee, .aside, .hero-marquee, .quiz-marquee') && !anchorTag.hash) anchorTag.hash = '#autoplay';\n  const { dataset, parentElement } = anchorTag;\n  const attrs = getVideoAttrs(anchorTag.hash, dataset);\n  const tabIndex = anchorTag.tabIndex || 0;\n  const videoIndex = (tabIndex === -1) ? 'tabindex=-1' : '';\n  let video = `<video ${attrs} data-video-source=${src} ${videoIndex}></video>`;\n  if (!attrs.includes('controls') && !attrs.includes('hoverplay') && accessibilityEnabled) {\n    videoCounter += 1;\n  }\n  const indexOfVideo = videoCounter;\n  if (accessibilityEnabled) {\n    video = addAccessibilityControl(video, attrs, indexOfVideo, tabIndex);\n  }\n  anchorTag.insertAdjacentHTML('afterend', video);\n  const videoEl = parentElement.querySelector('video');\n  if (indexOfVideo === 1) {\n    firstVideo = videoEl;\n  }\n  createIntersectionObserver({\n    el: videoEl,\n    options: { rootMargin: '1000px' },\n    callback: () => {\n      videoEl?.appendChild(createTag('source', { src, type: 'video/mp4' }));\n    },\n  });\n  if (videoEl.controls) {\n    const io = new IntersectionObserver((entries) => {\n      entries.forEach(({ isIntersecting, target }) => {\n        if (!isIntersecting && !target.paused) target.pause();\n      });\n    }, { rootMargin: '0px' });\n    io.observe(videoEl);\n  }\n\n  if (accessibilityEnabled) {\n    applyAccessibilityEvents(videoEl);\n    if (!videoEl.controls) {\n      decoratePausePlayWrapper(videoEl, attrs);\n    }\n  }\n  applyHoverPlay(videoEl);\n  applyInViewPortPlay(videoEl);\n  anchorTag.remove();\n}\n","import { handleFocalpoint } from '../../utils/decorate.js';\n\nexport function handleBackground(div, section) {\n  const pic = div.background.content?.querySelector('picture');\n  if (pic) {\n    section.classList.add('has-background');\n    pic.classList.add('section-background');\n    handleFocalpoint(pic, div.background.content);\n    section.insertAdjacentElement('afterbegin', pic);\n  } else {\n    const color = div.background.content?.textContent;\n    if (color) {\n      section.style.background = color;\n    }\n  }\n}\n\nexport async function handleStyle(text, section) {\n  if (!text || !section) return;\n  const styles = text.split(', ').map((style) => style.replaceAll(' ', '-'));\n  const sticky = styles.find((style) => style === 'sticky-top' || style === 'sticky-bottom');\n  if (sticky) {\n    const { default: handleStickySection } = await import('./sticky-section.js');\n    await handleStickySection(sticky, section);\n  }\n  if (styles.includes('masonry')) styles.push('masonry-up');\n  section.classList.add(...styles);\n}\n\nfunction handleMasonry(text, section) {\n  section.classList.add(...['masonry-layout', 'masonry-up']);\n  const divs = section.querySelectorAll(\":scope > div:not([class*='metadata'])\");\n  const spans = [];\n  text.split('\\n').forEach((line) => spans.push(...line.trim().split(',')));\n  [...divs].forEach((div, i) => {\n    const spanWidth = spans[i] ? spans[i] : 'span 4';\n    div.classList.add(`grid-${spanWidth.trim().replace(' ', '-')}`);\n  });\n}\n\nfunction handleLayout(text, section) {\n  if (!(text || section)) return;\n  const layoutClass = `grid-template-columns-${text.replaceAll(' | ', '-')}`;\n  section.classList.add(layoutClass);\n}\n\nexport function getDelayTime(time) {\n  if (time > 99) return time;\n  return (time * 1000);\n}\n\nfunction handleDelay(time, section) {\n  if (!(time || section)) return;\n  section.classList.add('hide-sticky-section');\n  setTimeout(() => { section.classList.remove('hide-sticky-section'); }, getDelayTime(time));\n}\n\nfunction handleAnchor(anchor, section) {\n  if (!anchor || !section) return;\n  section.id = anchor.toLowerCase().trim().replaceAll(/\\s+/g, '-');\n  section.classList.add('section-anchor');\n}\n\nexport const getMetadata = (el) => [...el.childNodes].reduce((rdx, row) => {\n  if (row.children) {\n    const key = row.children[0].textContent.trim().toLowerCase();\n    const content = row.children[1];\n    const text = content.textContent.trim().toLowerCase();\n    if (key && content) rdx[key] = { content, text };\n  }\n  return rdx;\n}, {});\n\nexport default async function init(el) {\n  const section = el.closest('.section');\n  const metadata = getMetadata(el);\n  if (metadata.style) await handleStyle(metadata.style.text, section);\n  if (metadata.background) handleBackground(metadata, section);\n  if (metadata.layout) handleLayout(metadata.layout.text, section);\n  if (metadata.masonry) handleMasonry(metadata.masonry.text, section);\n  if (metadata.delay) handleDelay(metadata.delay.text, section);\n  if (metadata.anchor) handleAnchor(metadata.anchor.text, section);\n}\n","import { createTag } from '../../utils/utils.js';\nimport { getMetadata, getDelayTime } from './section-metadata.js';\nimport { getGnavHeight } from '../global-navigation/utilities/utilities.js';\n\nfunction handleTopHeight(section) {\n  const topHeight = getGnavHeight();\n  section.style.top = `${topHeight}px`;\n}\n\nfunction promoIntersectObserve(el, stickySectionEl, options = {}) {\n  const io = new IntersectionObserver((entries, observer) => {\n    entries.forEach((entry) => {\n      if (el.classList.contains('close-sticky-section')) {\n        window.removeEventListener('resize', handleTopHeight);\n        observer.unobserve(entry.target);\n        return;\n      }\n\n      const abovePromoStart = (entry.target === stickySectionEl && entry.isIntersecting)\n        || stickySectionEl?.getBoundingClientRect().y > 0;\n\n      if (entry.target === document.querySelector('footer')) {\n        el.classList.toggle('fill-sticky-section', entry.isIntersecting);\n      } else el.classList.toggle('hide-sticky-section', abovePromoStart);\n    });\n  }, options);\n  return io;\n}\n\nfunction handleStickyPromobar(section, delay) {\n  const main = document.querySelector('main');\n  section.classList.add('promo-sticky-section', 'hide-sticky-section');\n  if (section.querySelector('.popup:is(.promobar)')) section.classList.add('popup');\n  let stickySectionEl = null;\n  let hasScrollControl;\n  if ((section.querySelector(':is(.promobar, .notification)').classList.contains('no-delay'))\n    || (delay && section.classList.contains('popup'))) {\n    hasScrollControl = true;\n    section.classList.remove('hide-sticky-section');\n  }\n  if (!hasScrollControl && main.children[0] !== section) {\n    stickySectionEl = createTag('div', { class: 'section show-sticky-section' });\n    section.parentElement.insertBefore(stickySectionEl, section);\n  }\n  const io = promoIntersectObserve(section, stickySectionEl);\n  if (stickySectionEl) io.observe(stickySectionEl);\n  if (section.querySelector(':is(.promobar, .notification)')) {\n    io.observe(document.querySelector('footer'));\n  }\n}\n\nexport default async function handleStickySection(sticky, section) {\n  const main = document.querySelector('main');\n  switch (sticky) {\n    case 'sticky-top': {\n      const { debounce } = await import('../../utils/action.js');\n      window.addEventListener('resize', debounce(() => handleTopHeight(section)));\n      handleTopHeight(section);\n      main.prepend(section);\n      break;\n    }\n    case 'sticky-bottom': {\n      if (section.querySelector(':is(.promobar, .notification)')) {\n        const metadata = getMetadata(section.querySelector('.section-metadata'));\n        const delay = getDelayTime(metadata.delay?.text);\n        if (delay) setTimeout(() => { handleStickyPromobar(section, delay); }, delay);\n        else handleStickyPromobar(section, delay);\n      }\n      main.append(section);\n      break;\n    }\n    default:\n      break;\n  }\n}\n"],"names":["_taggedTemplateLiteral","e","t","slice","Object","freeze","defineProperties","raw","value","miloLibs","codeRoot","getConfig","handleBackground","div","section","_div$background$conte","pic","background","content","querySelector","classList","add","child","removeChild","image","text","childElementCount","dataElement","querySelectorAll","textContent","remove","childData","childNodes","forEach","c","nodeType","Node","TEXT_NODE","directions","trim","toLowerCase","split","x","y","style","objectPosition","concat","handleFocalpoint","insertAdjacentElement","_div$background$conte2","color","handleStyle","styles","map","replaceAll","sticky","find","default","handleStickySection","includes","push","getDelayTime","time","getMetadata","el","reduce","rdx","row","children","key","init","closest","metadata","layout","layoutClass","handleLayout","masonry","divs","spans","line","i","spanWidth","replace","handleMasonry","delay","setTimeout","handleDelay","anchor","id","handleAnchor","handleTopHeight","topHeight","getGnavHeight","top","handleStickyPromobar","main","document","hasScrollControl","stickySectionEl","contains","createTag","class","parentElement","insertBefore","io","IntersectionObserver","entries","observer","entry","window","removeEventListener","unobserve","target","abovePromoStart","isIntersecting","getBoundingClientRect","toggle","arguments","length","undefined","promoIntersectObserve","observe","debounce","addEventListener","prepend","_metadata$delay","append"],"sourceRoot":""}